<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Hamiltonian Diagonalization: utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Hamiltonian Diagonalization
   &#160;<span id="projectnumber">Version 1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceutilities.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">utilities Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceutilities_1_1binary"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1binary.html">binary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceutilities_1_1linearAlgebra"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html">linearAlgebra</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1MurmurHasher32Wrapper.html">MurmurHasher32Wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1MurmurHasher64Wrapper.html">MurmurHasher64Wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1MpiWrapper.html">MpiWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct of variables and functions that can be used to pass MPI interface between functions.  <a href="structutilities_1_1MpiWrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1SqliteVariable.html">SqliteVariable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1SqliteRow.html">SqliteRow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to contain is list of SqliteVariables to form a single row in an <a class="el" href="classutilities_1_1Sqlite.html" title="A wrapper class for SQLlite functions. ">Sqlite</a> table.  <a href="classutilities_1_1SqliteRow.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Sqlite.html">Sqlite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class for SQLlite functions.  <a href="classutilities_1_1Sqlite.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1ClebschGordanCoefficients.html">ClebschGordanCoefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ClebschGordonCoefficients class contains a look-up table of pre-calculated Clebsch-Gordan coefficients.  <a href="classutilities_1_1ClebschGordanCoefficients.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Script.html">Script</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to convert a given string to a text file and execute it as a script.  <a href="classutilities_1_1Script.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Cout.html">Cout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a class to contain functions that control the verbosity level of cout output. An object of this class type should be declared as a global extern, with a single instance declared in the main file.  <a href="classutilities_1_1Cout.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__same.html">is_same</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template to check that two types are the same (as implemented by the function std::is_same in C++11)  <a href="structutilities_1_1is__same.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__same_3_01T_00_01T_01_4.html">is_same&lt; T, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template to check that two types are the same (as implemented by the function std::is_same in C++11)  <a href="structutilities_1_1is__same_3_01T_00_01T_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1SizeOfImpl.html">SizeOfImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">g++ does not correctly implemented partial variadic template function specialization. The workaround is to use a recursive set of classes, which contain the function that we wanted to use (see below)  <a href="structutilities_1_1SizeOfImpl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1SizeOfImpl_3_4.html">SizeOfImpl&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class to count the total number of bytes in a variadic template parameter pack (requires c++11). Count total number of bytes - iterator in case of a single remaining argument.  <a href="structutilities_1_1SizeOfImpl_3_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1SizeOfImpl_3_01T_00_01Ts_8_8_8_4.html">SizeOfImpl&lt; T, Ts...&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class to count the total number of bytes in a variadic template parameter pack (requires c++11). Count total number of bytes - iterator in case of multiple parameters.  <a href="structutilities_1_1SizeOfImpl_3_01T_00_01Ts_8_8_8_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to provide a simple timer to record the time between the class being constructed and destroyed.  <a href="classutilities_1_1Timer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1LoadBar.html">LoadBar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to display a progress bar.  <a href="classutilities_1_1LoadBar.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1MappedSparseMatrix.html">MappedSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to implement the mapped sparse matrix format.  <a href="classutilities_1_1MappedSparseMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1CrsSparseMatrix.html">CrsSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class to implement the compressed row storage sparse matrix format.  <a href="classutilities_1_1CrsSparseMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1pair.html">pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1MultiHashBase.html">MultiHashBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to contain implementations of utility functions used in either the <a class="el" href="classutilities_1_1MultiHashMap.html">MultiHashMap</a> or <a class="el" href="classutilities_1_1MultiHashMultiMap.html">MultiHashMultiMap</a> classes below.  <a href="classutilities_1_1MultiHashBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1MultiHashMap.html">MultiHashMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1MultiHashMultiMap.html">MultiHashMultiMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Compare.html">Compare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to contain a comparison function used by the sorting algorithm, built with some template metaprogramming tricks.  <a href="structutilities_1_1Compare.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Compare_3_01K_00_01__ASCENDING__ORDER___01_4.html">Compare&lt; K, _ASCENDING_ORDER_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to contain a comparison function used by the sorting algorithm, built with some template metaprogramming tricks.  <a href="structutilities_1_1Compare_3_01K_00_01__ASCENDING__ORDER___01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Compare_3_01K_00_01__DESCENDING__ORDER___01_4.html">Compare&lt; K, _DESCENDING_ORDER_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to contain a comparison function used by the sorting algorithm, built with some template metaprogramming tricks.  <a href="structutilities_1_1Compare_3_01K_00_01__DESCENDING__ORDER___01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Compare_3_01std_1_1pair_3_01uint64__t_00_01dcmplx_01_4_00_01__ASCENDING__ORDER___01_4.html">Compare&lt; std::pair&lt; uint64_t, dcmplx &gt;, _ASCENDING_ORDER_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to contain a comparison function used by the sorting algorithm, built with some template metaprogramming tricks.  <a href="structutilities_1_1Compare_3_01std_1_1pair_3_01uint64__t_00_01dcmplx_01_4_00_01__ASCENDING__ORDER___01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Compare_3_01std_1_1pair_3_01uint64__t_00_01dcmplx_01_4_00_01__DESCENDING__ORDER___01_4.html">Compare&lt; std::pair&lt; uint64_t, dcmplx &gt;, _DESCENDING_ORDER_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to contain a comparison function used by the sorting algorithm, built with some template metaprogramming tricks.  <a href="structutilities_1_1Compare_3_01std_1_1pair_3_01uint64__t_00_01dcmplx_01_4_00_01__DESCENDING__ORDER___01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Compare_3_01dcmplx_00_01__ASCENDING__ORDER___01_4.html">Compare&lt; dcmplx, _ASCENDING_ORDER_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to contain a comparison function used by the sorting algorithm, built with some template metaprogramming tricks.  <a href="structutilities_1_1Compare_3_01dcmplx_00_01__ASCENDING__ORDER___01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Compare_3_01dcmplx_00_01__DESCENDING__ORDER___01_4.html">Compare&lt; dcmplx, _DESCENDING_ORDER_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to contain a comparison function used by the sorting algorithm, built with some template metaprogramming tricks.  <a href="structutilities_1_1Compare_3_01dcmplx_00_01__DESCENDING__ORDER___01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1LatticeVector2D.html">LatticeVector2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a data type to contain a 2D vector, used to represent lattice vectors. This data type has various arithmetic operator overloads declared.  <a href="classutilities_1_1LatticeVector2D.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1KahanAccumulation.html">KahanAccumulation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab91e73704a0edaa02e48c3aaf68b1e13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13">vLevel</a> { <br/>
&#160;&#160;<a class="el" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a78d55c3f18a751bd8cf0b8bc591d22d3">_OUTPUT_OFF_</a> =0, 
<a class="el" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a4df5e1ccafc7d717a6ceee83ec7731e6">_MAIN_OUTPUT_</a> =1, 
<a class="el" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13af305aef246db9a9f4424bcf0dcef71d8">_SECONDARY_OUTPUT_</a> =2, 
<a class="el" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a06c96eabb42a12a9377cd5a6c2622f52">_ADDITIONAL_INFO_</a> =3, 
<br/>
&#160;&#160;<a class="el" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a9f19fd5fdb2d15fa16757d29ef5121b6">_DEBUGGING_INFO_</a> =4
<br/>
 }</td></tr>
<tr class="separator:ab91e73704a0edaa02e48c3aaf68b1e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b56581bf350587fe56b04f31c5c6d7f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a2b56581bf350587fe56b04f31c5c6d7f">storageMethod_t</a> { <a class="el" href="namespaceutilities.html#a2b56581bf350587fe56b04f31c5c6d7fa93ce5b7069ae9c47bc7d6f11960de59c">_SPARSE_MAPPED_</a>, 
<a class="el" href="namespaceutilities.html#a2b56581bf350587fe56b04f31c5c6d7fa38d333d034a55c156caec5e0712dc330">_SPARSE_CRS_</a>, 
<a class="el" href="namespaceutilities.html#a2b56581bf350587fe56b04f31c5c6d7fa00469b74ffceb5e099a54fda40a970cd">_DENSE_</a>
 }</td></tr>
<tr class="separator:a2b56581bf350587fe56b04f31c5c6d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6715279226011811c3b4f3b41c36024b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6715279226011811c3b4f3b41c36024b"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a6715279226011811c3b4f3b41c36024b">MurmurHasher64</a> (const T &amp;t, const unsigned int seed)</td></tr>
<tr class="separator:a6715279226011811c3b4f3b41c36024b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f6e5cd6f08f4e47e1a00c3ebebc827"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a85f6e5cd6f08f4e47e1a00c3ebebc827"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a85f6e5cd6f08f4e47e1a00c3ebebc827">GenFileStream</a> (F &amp;stream, const std::string fileName, <a class="el" href="namespaceio.html#a21deb8bdc22417a8eb07113769d6c601">io::fileFormat_t</a> format, <a class="el" href="structutilities_1_1MpiWrapper.html">utilities::MpiWrapper</a> &amp;<a class="el" href="fqhe__sphere__spinless__fermions__diagonalization_8cpp.html#a1a7112d51c59f426cab52975031ff6e7">mpi</a>)</td></tr>
<tr class="separator:a85f6e5cd6f08f4e47e1a00c3ebebc827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa7f7439072020c4a0dbd6f0fbe85b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5aa7f7439072020c4a0dbd6f0fbe85b8"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a5aa7f7439072020c4a0dbd6f0fbe85b8">ToStream</a> (T variable)</td></tr>
<tr class="separator:a5aa7f7439072020c4a0dbd6f0fbe85b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6afaf89e9c2b614a690c5bae5ea984"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a2a6afaf89e9c2b614a690c5bae5ea984">FromStream</a> (std::ifstream &amp;stream, double &amp;value)</td></tr>
<tr class="separator:a2a6afaf89e9c2b614a690c5bae5ea984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6e06d2f7e1c9919a80f6a4328396d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a6a6e06d2f7e1c9919a80f6a4328396d2">FromStream</a> (std::ifstream &amp;stream, short unsigned int &amp;value)</td></tr>
<tr class="separator:a6a6e06d2f7e1c9919a80f6a4328396d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c64c8f0bb89708c40710bc4af5e5e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a80c64c8f0bb89708c40710bc4af5e5e0">FromStream</a> (std::ifstream &amp;stream, <a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> &amp;value)</td></tr>
<tr class="separator:a80c64c8f0bb89708c40710bc4af5e5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab535008cab9192c3da1bbca22e841f38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ab535008cab9192c3da1bbca22e841f38">DiscreteFourierTransform1D</a> (int N, int M, <a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *inputs, <a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *outputs, int sign)</td></tr>
<tr class="memdesc:ab535008cab9192c3da1bbca22e841f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a series of 1D discrete Fourier transforms.  <a href="#ab535008cab9192c3da1bbca22e841f38">More...</a><br/></td></tr>
<tr class="separator:ab535008cab9192c3da1bbca22e841f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4e0749cf92abf92f2b0290ae0639a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0a4e0749cf92abf92f2b0290ae0639a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a0a4e0749cf92abf92f2b0290ae0639a6">GetOption</a> (boost::program_options::variables_map *variables_map, T &amp;variable, const std::string name, const std::string location)</td></tr>
<tr class="separator:a0a4e0749cf92abf92f2b0290ae0639a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af912b9c930103dc57531d1d9b997d27a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af912b9c930103dc57531d1d9b997d27a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#af912b9c930103dc57531d1d9b997d27a">GetOption</a> (boost::program_options::variables_map *variables_map, T &amp;variable, const std::string name, const std::string location, <a class="el" href="structutilities_1_1MpiWrapper.html">utilities::MpiWrapper</a> &amp;<a class="el" href="fqhe__sphere__spinless__fermions__diagonalization_8cpp.html#a1a7112d51c59f426cab52975031ff6e7">mpi</a>)</td></tr>
<tr class="separator:af912b9c930103dc57531d1d9b997d27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3189851e15d3e3b0138be97bcadc4c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a6c3189851e15d3e3b0138be97bcadc4c">Pack2x8</a> (const uint8_t key1, const uint8_t key2)</td></tr>
<tr class="separator:a6c3189851e15d3e3b0138be97bcadc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc87434bf622613d7849d56d37f885f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#abc87434bf622613d7849d56d37f885f3">Unpack2x8</a> (const uint16_t index, uint8_t &amp;key1, uint8_t &amp;key2)</td></tr>
<tr class="separator:abc87434bf622613d7849d56d37f885f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82140e289799af3dd4f0638c730faf3f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a82140e289799af3dd4f0638c730faf3f">Pack2x16</a> (const uint16_t key1, const uint16_t key2)</td></tr>
<tr class="separator:a82140e289799af3dd4f0638c730faf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb9f8e8d730a8d61070808dde979398"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a6bb9f8e8d730a8d61070808dde979398">Unpack2x16</a> (const uint32_t index, uint16_t &amp;key1, uint16_t &amp;key2)</td></tr>
<tr class="separator:a6bb9f8e8d730a8d61070808dde979398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88f2e607b1e3541233edf2bd7ee44ab"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#aa88f2e607b1e3541233edf2bd7ee44ab">Pack2x32</a> (const uint32_t key1, const uint32_t key2)</td></tr>
<tr class="separator:aa88f2e607b1e3541233edf2bd7ee44ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307f22a0ca92ed7ec48931314b9cf8dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a307f22a0ca92ed7ec48931314b9cf8dd">Unpack2x32</a> (const uint64_t index, uint32_t &amp;key1, uint32_t &amp;key2)</td></tr>
<tr class="separator:a307f22a0ca92ed7ec48931314b9cf8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78b0dbfe83aa9c7055214013b2d2b40"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ab78b0dbfe83aa9c7055214013b2d2b40">Pack4x16</a> (const uint16_t key1, const uint16_t key2, const uint16_t key3, const uint16_t key4)</td></tr>
<tr class="separator:ab78b0dbfe83aa9c7055214013b2d2b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095a3b7adb942010942db6922145aebf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a095a3b7adb942010942db6922145aebf">Unpack4x16</a> (const uint64_t index, uint16_t &amp;key1, uint16_t &amp;key2, uint16_t &amp;key3, uint16_t &amp;key4)</td></tr>
<tr class="separator:a095a3b7adb942010942db6922145aebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0d157baa23b47b75d49bf4bb08ff3f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#abf0d157baa23b47b75d49bf4bb08ff3f">Pack8x8</a> (const uint8_t key1, const uint8_t key2, const uint8_t key3, const uint8_t key4, const uint8_t key5, const uint8_t key6, const uint8_t key7, const uint8_t key8)</td></tr>
<tr class="separator:abf0d157baa23b47b75d49bf4bb08ff3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f08a26fc2b365a16c0a0e9fe09e716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a48f08a26fc2b365a16c0a0e9fe09e716">Unpack8x8</a> (const uint64_t index, uint8_t &amp;key1, uint8_t &amp;key2, uint8_t &amp;key3, uint8_t &amp;key4, uint8_t &amp;key5, uint8_t &amp;key6, uint8_t &amp;key7, uint8_t &amp;key8)</td></tr>
<tr class="separator:a48f08a26fc2b365a16c0a0e9fe09e716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd63552e5e0ddf1735b427459222a91"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a2dd63552e5e0ddf1735b427459222a91"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a2dd63552e5e0ddf1735b427459222a91">SizeOf</a> ()</td></tr>
<tr class="memdesc:a2dd63552e5e0ddf1735b427459222a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template function to count the total number of bytes in a variadic template parameter pack (requires c++11)  <a href="#a2dd63552e5e0ddf1735b427459222a91">More...</a><br/></td></tr>
<tr class="separator:a2dd63552e5e0ddf1735b427459222a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e23dff4b05b4b7f63377f11013c020"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af0e23dff4b05b4b7f63377f11013c020"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#af0e23dff4b05b4b7f63377f11013c020">SameTest</a> (<a class="el" href="classutilities_1_1MappedSparseMatrix.html">MappedSparseMatrix</a>&lt; T &gt; &amp;lhs, <a class="el" href="classutilities_1_1MappedSparseMatrix.html">MappedSparseMatrix</a>&lt; T &gt; &amp;rhs, const double tol)</td></tr>
<tr class="memdesc:af0e23dff4b05b4b7f63377f11013c020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator to test if two <a class="el" href="classutilities_1_1CrsSparseMatrix.html" title="A template class to implement the compressed row storage sparse matrix format. ">CrsSparseMatrix</a> data structures are identical up to a given tolerence. Only classes with the same template arguments can be compared.  <a href="#af0e23dff4b05b4b7f63377f11013c020">More...</a><br/></td></tr>
<tr class="separator:af0e23dff4b05b4b7f63377f11013c020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d4d9a9873d5f7908484e6aa41c2fd7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9d4d9a9873d5f7908484e6aa41c2fd7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ae9d4d9a9873d5f7908484e6aa41c2fd7">SameTest</a> (<a class="el" href="classutilities_1_1CrsSparseMatrix.html">CrsSparseMatrix</a>&lt; T &gt; &amp;lhs, <a class="el" href="classutilities_1_1CrsSparseMatrix.html">CrsSparseMatrix</a>&lt; T &gt; &amp;rhs, const double tol)</td></tr>
<tr class="memdesc:ae9d4d9a9873d5f7908484e6aa41c2fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator to test if two <a class="el" href="classutilities_1_1CrsSparseMatrix.html" title="A template class to implement the compressed row storage sparse matrix format. ">CrsSparseMatrix</a> data structures are identical up to a given tolerence. Only classes with the same template arguments can be compared.  <a href="#ae9d4d9a9873d5f7908484e6aa41c2fd7">More...</a><br/></td></tr>
<tr class="separator:ae9d4d9a9873d5f7908484e6aa41c2fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb04e305126905376344007e049f9ae8"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#acb04e305126905376344007e049f9ae8">Key</a> (const uint32_t key1, const uint32_t key2)</td></tr>
<tr class="memdesc:acb04e305126905376344007e049f9ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to generate a 64-bit hash key from 2 input arguments.  <a href="#acb04e305126905376344007e049f9ae8">More...</a><br/></td></tr>
<tr class="separator:acb04e305126905376344007e049f9ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba3ae5b3df05fa8bb813e193e265105"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#aeba3ae5b3df05fa8bb813e193e265105">Key</a> (const uint16_t key1, const uint16_t key2, const uint16_t key3)</td></tr>
<tr class="memdesc:aeba3ae5b3df05fa8bb813e193e265105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to generate a 64-bit hash key from 3 input arguments.  <a href="#aeba3ae5b3df05fa8bb813e193e265105">More...</a><br/></td></tr>
<tr class="separator:aeba3ae5b3df05fa8bb813e193e265105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba8b5f1a9b0ffc02a8038527577d8d5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a6ba8b5f1a9b0ffc02a8038527577d8d5">Key</a> (const uint16_t key1, const uint16_t key2, const uint16_t key3, const uint16_t key4)</td></tr>
<tr class="memdesc:a6ba8b5f1a9b0ffc02a8038527577d8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to generate a 64-bit hash key from 4 input arguments.  <a href="#a6ba8b5f1a9b0ffc02a8038527577d8d5">More...</a><br/></td></tr>
<tr class="separator:a6ba8b5f1a9b0ffc02a8038527577d8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028c87729a53688016b10a2202ceb82b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a028c87729a53688016b10a2202ceb82b">Key</a> (const uint8_t key1, const uint8_t key2, const uint8_t key3, const uint8_t key4, const uint8_t key5, const uint8_t key6)</td></tr>
<tr class="memdesc:a028c87729a53688016b10a2202ceb82b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to generate a 64-bit hash key from 6 input arguments.  <a href="#a028c87729a53688016b10a2202ceb82b">More...</a><br/></td></tr>
<tr class="separator:a028c87729a53688016b10a2202ceb82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ba1caa17dfee74cd81fea7018e53f4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ae1ba1caa17dfee74cd81fea7018e53f4">Key</a> (const uint8_t key1, const uint8_t key2, const uint8_t key3, const uint8_t key4, const uint8_t key5, const uint8_t key6, const uint8_t key7, const uint8_t key8)</td></tr>
<tr class="memdesc:ae1ba1caa17dfee74cd81fea7018e53f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to generate a 64-bit hash key from 8 input arguments.  <a href="#ae1ba1caa17dfee74cd81fea7018e53f4">More...</a><br/></td></tr>
<tr class="separator:ae1ba1caa17dfee74cd81fea7018e53f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4186e485e8332d7bdeca00b7ce89cc6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4186e485e8332d7bdeca00b7ce89cc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a> (T *&amp;a, T *&amp;b)</td></tr>
<tr class="memdesc:aa4186e485e8332d7bdeca00b7ce89cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template for a swap function, to swap the contents of two memory addresses. This version is used as an alternative to the std::swap function which does not quite have the correct behaviour for this application (since std:swap swaps the pointers, not the addresses pointed to, given the same set of arguments as with this Swap function).  <a href="#aa4186e485e8332d7bdeca00b7ce89cc6">More...</a><br/></td></tr>
<tr class="separator:aa4186e485e8332d7bdeca00b7ce89cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af9c3d98c2afbb6d16e02fa26806e4f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , order_t O&gt; </td></tr>
<tr class="memitem:a9af9c3d98c2afbb6d16e02fa26806e4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a9af9c3d98c2afbb6d16e02fa26806e4f">DoQuickSort</a> (K *keyList, V *valueList, const unsigned int &amp;dim, const unsigned int &amp;nSort, unsigned int &amp;maxSorted)</td></tr>
<tr class="memdesc:a9af9c3d98c2afbb6d16e02fa26806e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts keys and values lists according to the keys list. Returns after the first nSort elements are sorted. Sorting is performed with an in-place quick sort algorithm, with the pivot chosen as the median of the first, middle and last element of the partition.  <a href="#a9af9c3d98c2afbb6d16e02fa26806e4f">More...</a><br/></td></tr>
<tr class="separator:a9af9c3d98c2afbb6d16e02fa26806e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca89a1ba48fbce62db30823827b3823"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , order_t O&gt; </td></tr>
<tr class="memitem:a8ca89a1ba48fbce62db30823827b3823"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a8ca89a1ba48fbce62db30823827b3823">PartialQuickSort</a> (K *keyList, V *valueList, const unsigned int dim, const unsigned int nSort)</td></tr>
<tr class="memdesc:a8ca89a1ba48fbce62db30823827b3823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts keys and values lists according to the keys list and returns after nSort values are in the correct order. This function is a wrapper to call the top level of the DoPairedSort recursion.  <a href="#a8ca89a1ba48fbce62db30823827b3823">More...</a><br/></td></tr>
<tr class="separator:a8ca89a1ba48fbce62db30823827b3823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e2efbf7451dbf878abd66dead65af9"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , order_t O&gt; </td></tr>
<tr class="memitem:a62e2efbf7451dbf878abd66dead65af9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a62e2efbf7451dbf878abd66dead65af9">PartialQuickSort</a> (K *keyList, const unsigned int dim, const unsigned int nSort)</td></tr>
<tr class="memdesc:a62e2efbf7451dbf878abd66dead65af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the PartialQuickSort function in case where only a key list is available. In this case the key list is not required.  <a href="#a62e2efbf7451dbf878abd66dead65af9">More...</a><br/></td></tr>
<tr class="separator:a62e2efbf7451dbf878abd66dead65af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a324083a2609dbfaf7f4c7c061a642e"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , order_t O&gt; </td></tr>
<tr class="memitem:a8a324083a2609dbfaf7f4c7c061a642e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a8a324083a2609dbfaf7f4c7c061a642e">PartialQuickSort</a> (std::vector&lt; K &gt; &amp;keyList, const unsigned int nSort)</td></tr>
<tr class="memdesc:a8a324083a2609dbfaf7f4c7c061a642e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the PartialQuickSort function for std::vector data structures.  <a href="#a8a324083a2609dbfaf7f4c7c061a642e">More...</a><br/></td></tr>
<tr class="separator:a8a324083a2609dbfaf7f4c7c061a642e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6360e7d29cb5c366b2813125684240"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , order_t O&gt; </td></tr>
<tr class="memitem:a6c6360e7d29cb5c366b2813125684240"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a6c6360e7d29cb5c366b2813125684240">QuickSort</a> (K *keyList, V *valueList, const unsigned int dim)</td></tr>
<tr class="memdesc:a6c6360e7d29cb5c366b2813125684240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts keys and values lists according to the keys list. This function is a wrapper to call the top level of the DoPairedSort recursion.  <a href="#a6c6360e7d29cb5c366b2813125684240">More...</a><br/></td></tr>
<tr class="separator:a6c6360e7d29cb5c366b2813125684240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847133334345e4979fbe17eb7e9ab4c7"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , order_t O&gt; </td></tr>
<tr class="memitem:a847133334345e4979fbe17eb7e9ab4c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a847133334345e4979fbe17eb7e9ab4c7">QuickSort</a> (K *keyList, const unsigned int dim)</td></tr>
<tr class="memdesc:a847133334345e4979fbe17eb7e9ab4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the QuickSort function in case where only a key list is available. In this case the key list is not required.  <a href="#a847133334345e4979fbe17eb7e9ab4c7">More...</a><br/></td></tr>
<tr class="separator:a847133334345e4979fbe17eb7e9ab4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bf9f1e05191efbf167362c0df48102"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , order_t O&gt; </td></tr>
<tr class="memitem:a24bf9f1e05191efbf167362c0df48102"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a24bf9f1e05191efbf167362c0df48102">QuickSort</a> (std::vector&lt; K &gt; &amp;keyList)</td></tr>
<tr class="memdesc:a24bf9f1e05191efbf167362c0df48102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the QuickSort function for std::vector data structures.  <a href="#a24bf9f1e05191efbf167362c0df48102">More...</a><br/></td></tr>
<tr class="separator:a24bf9f1e05191efbf167362c0df48102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164de456dfa80963cf9884fd0f421500"><td class="memTemplParams" colspan="2">template&lt;class T , typename I &gt; </td></tr>
<tr class="memitem:a164de456dfa80963cf9884fd0f421500"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="i__const__def_8hpp.html#ab03128f28254e912f824640e69fc85ad">I</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a164de456dfa80963cf9884fd0f421500">BinarySearch</a> (const T &amp;value, const T *array, <a class="el" href="i__const__def_8hpp.html#ab03128f28254e912f824640e69fc85ad">I</a> dim)</td></tr>
<tr class="memdesc:a164de456dfa80963cf9884fd0f421500"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given value, determine its index with a lexicographically ordered array of values. Only the first instance is returned.  <a href="#a164de456dfa80963cf9884fd0f421500">More...</a><br/></td></tr>
<tr class="separator:a164de456dfa80963cf9884fd0f421500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c998b8af25f017f89078615f9fd4e1"><td class="memTemplParams" colspan="2">template&lt;class T , typename I &gt; </td></tr>
<tr class="memitem:af6c998b8af25f017f89078615f9fd4e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="i__const__def_8hpp.html#ab03128f28254e912f824640e69fc85ad">I</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#af6c998b8af25f017f89078615f9fd4e1">BinarySearch</a> (const T &amp;value, const std::vector&lt; T &gt; &amp;array)</td></tr>
<tr class="memdesc:af6c998b8af25f017f89078615f9fd4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the binary search function for std::vector arrays.  <a href="#af6c998b8af25f017f89078615f9fd4e1">More...</a><br/></td></tr>
<tr class="separator:af6c998b8af25f017f89078615f9fd4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f98453d606e7a217fbfc6235c6ae11e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a6f98453d606e7a217fbfc6235c6ae11e">GetArrayConvolution1DSize</a> (const int leftDim, const int rightDim)</td></tr>
<tr class="memdesc:a6f98453d606e7a217fbfc6235c6ae11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to calculate and return the size of the convolved array, given the lengths of the input arrays and treating them as 1D arrays.  <a href="#a6f98453d606e7a217fbfc6235c6ae11e">More...</a><br/></td></tr>
<tr class="separator:a6f98453d606e7a217fbfc6235c6ae11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930275a6a3705cc50c3a7e59e080c120"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a930275a6a3705cc50c3a7e59e080c120"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a930275a6a3705cc50c3a7e59e080c120">ArrayConvolution1D</a> (T *leftArray, const int leftDim, T *rightArray, const int rightDim, T *output, const int startOffset, const int endOffset)</td></tr>
<tr class="memdesc:a930275a6a3705cc50c3a7e59e080c120"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template function to emulate Mathematica's "ListCorrelate" function for arbitrary c++ data types stored in regular 1D arrays.  <a href="#a930275a6a3705cc50c3a7e59e080c120">More...</a><br/></td></tr>
<tr class="separator:a930275a6a3705cc50c3a7e59e080c120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb24afa4763ddf0b9128ae145f0a115"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a4eb24afa4763ddf0b9128ae145f0a115">GetArrayConvolution2DSize</a> (const int dimX, const int dimY)</td></tr>
<tr class="memdesc:a4eb24afa4763ddf0b9128ae145f0a115"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to calculate and return the size of the convolved array, given the lengths of the input arrays and treating them as 2D arrays.  <a href="#a4eb24afa4763ddf0b9128ae145f0a115">More...</a><br/></td></tr>
<tr class="separator:a4eb24afa4763ddf0b9128ae145f0a115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c36d896506baca457165063e09ff16"><td class="memTemplParams" colspan="2">template&lt;typename T , typename H , int P&gt; </td></tr>
<tr class="memitem:ac9c36d896506baca457165063e09ff16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ac9c36d896506baca457165063e09ff16">ArrayConvolution2D</a> (T *rightArray, T *leftArray, const int dimX, const int dimY, T *output, const int topOffset, const int leftOffset, const int bottomOffset, const int rightOffset)</td></tr>
<tr class="memdesc:ac9c36d896506baca457165063e09ff16"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template function to emulate Mathematica's "ListCorrelate" function for arbitrary c++ data types stored in regular arrays. This version of the function treats the arrays as 2 dimensional.  <a href="#ac9c36d896506baca457165063e09ff16">More...</a><br/></td></tr>
<tr class="separator:ac9c36d896506baca457165063e09ff16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a076d248f808f6ab243602dc157c797"><td class="memItemLeft" align="right" valign="top">long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a3a076d248f808f6ab243602dc157c797">BinomialFromTable</a> (const int n, const int k)</td></tr>
<tr class="memdesc:a3a076d248f808f6ab243602dc157c797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial look-up function protorype.  <a href="#a3a076d248f808f6ab243602dc157c797">More...</a><br/></td></tr>
<tr class="separator:a3a076d248f808f6ab243602dc157c797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a09b9ed8b3a53cb176844c576b0ce53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a09b9ed8b3a53cb176844c576b0ce53"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a8a09b9ed8b3a53cb176844c576b0ce53">Binomial</a> (T input1, T input2)</td></tr>
<tr class="memdesc:a8a09b9ed8b3a53cb176844c576b0ce53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the combinatoric factor input1 Choose input2. Inputs are double variables to avoid overflows.  <a href="#a8a09b9ed8b3a53cb176844c576b0ce53">More...</a><br/></td></tr>
<tr class="separator:a8a09b9ed8b3a53cb176844c576b0ce53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4525c2d723469d4a1738b867459aeb84"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a4525c2d723469d4a1738b867459aeb84">Evaluate_CdCdCC</a> (int &amp;coefficient, const uint64_t k1Occupied, const uint64_t k2Occupied, const uint64_t k3Occupied, const uint64_t k4Occupied, const uint64_t state, const uint64_t highestOrbital)</td></tr>
<tr class="memdesc:a4525c2d723469d4a1738b867459aeb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an operator c^+_k1 c^+_k2 c_k3 c_k4 to a given state (with k1+k2=k3+k4)  <a href="#a4525c2d723469d4a1738b867459aeb84">More...</a><br/></td></tr>
<tr class="separator:a4525c2d723469d4a1738b867459aeb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54074ad1aa43454e68e44d9a5d5cf349"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a54074ad1aa43454e68e44d9a5d5cf349">Evaluate_CdC</a> (int &amp;coefficient, const uint64_t k1Occupied, const uint64_t k2Occupied, const uint64_t state, const uint64_t highestOrbital)</td></tr>
<tr class="memdesc:a54074ad1aa43454e68e44d9a5d5cf349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an operator c^+_k1 c_k2 to a given state.  <a href="#a54074ad1aa43454e68e44d9a5d5cf349">More...</a><br/></td></tr>
<tr class="separator:a54074ad1aa43454e68e44d9a5d5cf349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bfadc2924da9f8a04e10c6a72a4891"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#af9bfadc2924da9f8a04e10c6a72a4891">Evaluate_CCd</a> (int &amp;coefficient, const uint64_t k1Occupied, const uint64_t k2Occupied, const uint64_t state, const uint64_t highestOrbital)</td></tr>
<tr class="memdesc:af9bfadc2924da9f8a04e10c6a72a4891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an operator c_k1 c^+_k2 to a given state.  <a href="#af9bfadc2924da9f8a04e10c6a72a4891">More...</a><br/></td></tr>
<tr class="separator:af9bfadc2924da9f8a04e10c6a72a4891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64be4b24f7781ae39f5dbfeb01a33659"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64be4b24f7781ae39f5dbfeb01a33659"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structutilities_1_1KahanAccumulation.html">KahanAccumulation</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a64be4b24f7781ae39f5dbfeb01a33659">operator+=</a> (<a class="el" href="structutilities_1_1KahanAccumulation.html">KahanAccumulation</a>&lt; T &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a64be4b24f7781ae39f5dbfeb01a33659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a global template += operator overload for the Kahan accumulator class. Call as simply a += b where a is an existing <a class="el" href="structutilities_1_1KahanAccumulation.html">KahanAccumulation</a> object and b is the numerical value to be added to the sum (should be of the same type as the class type)  <a href="#a64be4b24f7781ae39f5dbfeb01a33659">More...</a><br/></td></tr>
<tr class="separator:a64be4b24f7781ae39f5dbfeb01a33659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820763bcab8f0447427b392b07dbdadb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a820763bcab8f0447427b392b07dbdadb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a820763bcab8f0447427b392b07dbdadb">Modulo</a> (const T a, const T b)</td></tr>
<tr class="memdesc:a820763bcab8f0447427b392b07dbdadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template function that returns the result a modulo b, for both positive and negative values of a.  <a href="#a820763bcab8f0447427b392b07dbdadb">More...</a><br/></td></tr>
<tr class="separator:a820763bcab8f0447427b392b07dbdadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8bd217ae821e52872836b15f651f5d9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutilities_1_1Cout.html">Cout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a8bd217ae821e52872836b15f651f5d9f">cout</a></td></tr>
<tr class="separator:a8bd217ae821e52872836b15f651f5d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a58897161c5ac004869b8f994de5ff4"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a1a58897161c5ac004869b8f994de5ff4">maxBinomial</a> = 64</td></tr>
<tr class="separator:a1a58897161c5ac004869b8f994de5ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae923787d35bb2fff3ded45e174f1756c"><td class="memItemLeft" align="right" valign="top">static const long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ae923787d35bb2fff3ded45e174f1756c">binomialLookUpTable</a> []</td></tr>
<tr class="separator:ae923787d35bb2fff3ded45e174f1756c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a2b56581bf350587fe56b04f31c5c6d7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceutilities.html#a2b56581bf350587fe56b04f31c5c6d7f">utilities::storageMethod_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a storage method enum </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a2b56581bf350587fe56b04f31c5c6d7fa93ce5b7069ae9c47bc7d6f11960de59c"></a>_SPARSE_MAPPED_</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2b56581bf350587fe56b04f31c5c6d7fa38d333d034a55c156caec5e0712dc330"></a>_SPARSE_CRS_</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2b56581bf350587fe56b04f31c5c6d7fa00469b74ffceb5e099a54fda40a970cd"></a>_DENSE_</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="sparse__matrix_8hpp_source.html#l00055">55</a> of file <a class="el" href="sparse__matrix_8hpp_source.html">sparse_matrix.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;{<a class="code" href="namespaceutilities.html#a2b56581bf350587fe56b04f31c5c6d7fa93ce5b7069ae9c47bc7d6f11960de59c">_SPARSE_MAPPED_</a>,<a class="code" href="namespaceutilities.html#a2b56581bf350587fe56b04f31c5c6d7fa38d333d034a55c156caec5e0712dc330">_SPARSE_CRS_</a>,<a class="code" href="namespaceutilities.html#a2b56581bf350587fe56b04f31c5c6d7fa00469b74ffceb5e099a54fda40a970cd">_DENSE_</a>};</div>
<div class="ttc" id="namespaceutilities_html_a2b56581bf350587fe56b04f31c5c6d7fa00469b74ffceb5e099a54fda40a970cd"><div class="ttname"><a href="namespaceutilities.html#a2b56581bf350587fe56b04f31c5c6d7fa00469b74ffceb5e099a54fda40a970cd">utilities::_DENSE_</a></div><div class="ttdef"><b>Definition:</b> <a href="sparse__matrix_8hpp_source.html#l00055">sparse_matrix.hpp:55</a></div></div>
<div class="ttc" id="namespaceutilities_html_a2b56581bf350587fe56b04f31c5c6d7fa93ce5b7069ae9c47bc7d6f11960de59c"><div class="ttname"><a href="namespaceutilities.html#a2b56581bf350587fe56b04f31c5c6d7fa93ce5b7069ae9c47bc7d6f11960de59c">utilities::_SPARSE_MAPPED_</a></div><div class="ttdef"><b>Definition:</b> <a href="sparse__matrix_8hpp_source.html#l00055">sparse_matrix.hpp:55</a></div></div>
<div class="ttc" id="namespaceutilities_html_a2b56581bf350587fe56b04f31c5c6d7fa38d333d034a55c156caec5e0712dc330"><div class="ttname"><a href="namespaceutilities.html#a2b56581bf350587fe56b04f31c5c6d7fa38d333d034a55c156caec5e0712dc330">utilities::_SPARSE_CRS_</a></div><div class="ttdef"><b>Definition:</b> <a href="sparse__matrix_8hpp_source.html#l00055">sparse_matrix.hpp:55</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab91e73704a0edaa02e48c3aaf68b1e13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13">utilities::vLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ab91e73704a0edaa02e48c3aaf68b1e13a78d55c3f18a751bd8cf0b8bc591d22d3"></a>_OUTPUT_OFF_</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab91e73704a0edaa02e48c3aaf68b1e13a4df5e1ccafc7d717a6ceee83ec7731e6"></a>_MAIN_OUTPUT_</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab91e73704a0edaa02e48c3aaf68b1e13af305aef246db9a9f4424bcf0dcef71d8"></a>_SECONDARY_OUTPUT_</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab91e73704a0edaa02e48c3aaf68b1e13a06c96eabb42a12a9377cd5a6c2622f52"></a>_ADDITIONAL_INFO_</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab91e73704a0edaa02e48c3aaf68b1e13a9f19fd5fdb2d15fa16757d29ef5121b6"></a>_DEBUGGING_INFO_</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="cout__tools_8hpp_source.html#l00035">35</a> of file <a class="el" href="cout__tools_8hpp_source.html">cout_tools.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;                {<a class="code" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a78d55c3f18a751bd8cf0b8bc591d22d3">_OUTPUT_OFF_</a>=0, <a class="code" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a4df5e1ccafc7d717a6ceee83ec7731e6">_MAIN_OUTPUT_</a>=1, <a class="code" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13af305aef246db9a9f4424bcf0dcef71d8">_SECONDARY_OUTPUT_</a>=2, </div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                 <a class="code" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a06c96eabb42a12a9377cd5a6c2622f52">_ADDITIONAL_INFO_</a>=3, <a class="code" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a9f19fd5fdb2d15fa16757d29ef5121b6">_DEBUGGING_INFO_</a>=4};</div>
<div class="ttc" id="namespaceutilities_html_ab91e73704a0edaa02e48c3aaf68b1e13a9f19fd5fdb2d15fa16757d29ef5121b6"><div class="ttname"><a href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a9f19fd5fdb2d15fa16757d29ef5121b6">utilities::_DEBUGGING_INFO_</a></div><div class="ttdef"><b>Definition:</b> <a href="cout__tools_8hpp_source.html#l00036">cout_tools.hpp:36</a></div></div>
<div class="ttc" id="namespaceutilities_html_ab91e73704a0edaa02e48c3aaf68b1e13a78d55c3f18a751bd8cf0b8bc591d22d3"><div class="ttname"><a href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a78d55c3f18a751bd8cf0b8bc591d22d3">utilities::_OUTPUT_OFF_</a></div><div class="ttdef"><b>Definition:</b> <a href="cout__tools_8hpp_source.html#l00035">cout_tools.hpp:35</a></div></div>
<div class="ttc" id="namespaceutilities_html_ab91e73704a0edaa02e48c3aaf68b1e13af305aef246db9a9f4424bcf0dcef71d8"><div class="ttname"><a href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13af305aef246db9a9f4424bcf0dcef71d8">utilities::_SECONDARY_OUTPUT_</a></div><div class="ttdef"><b>Definition:</b> <a href="cout__tools_8hpp_source.html#l00035">cout_tools.hpp:35</a></div></div>
<div class="ttc" id="namespaceutilities_html_ab91e73704a0edaa02e48c3aaf68b1e13a4df5e1ccafc7d717a6ceee83ec7731e6"><div class="ttname"><a href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a4df5e1ccafc7d717a6ceee83ec7731e6">utilities::_MAIN_OUTPUT_</a></div><div class="ttdef"><b>Definition:</b> <a href="cout__tools_8hpp_source.html#l00035">cout_tools.hpp:35</a></div></div>
<div class="ttc" id="namespaceutilities_html_ab91e73704a0edaa02e48c3aaf68b1e13a06c96eabb42a12a9377cd5a6c2622f52"><div class="ttname"><a href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a06c96eabb42a12a9377cd5a6c2622f52">utilities::_ADDITIONAL_INFO_</a></div><div class="ttdef"><b>Definition:</b> <a href="cout__tools_8hpp_source.html#l00036">cout_tools.hpp:36</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a930275a6a3705cc50c3a7e59e080c120"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::ArrayConvolution1D </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>leftArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>leftDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rightArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>rightDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>endOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A template function to emulate Mathematica's "ListCorrelate" function for arbitrary c++ data types stored in regular 1D arrays. </p>
<p>IMPORTANT: the output array MUST be allocated with dimension given by the GetArrayConvolution1DSize function.</p>
<p>This function is equivalent to the Mathematica function:</p>
<p>ListCorrelate[rightArray,leftArray,{rightDim-startOffset,endOffset-rightDim},0]</p>
<p>(assuming that rightDim&lt;lefDim here) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftArray</td><td>Left 1D array to be convolved </td></tr>
    <tr><td class="paramname">leftDim</td><td>Dimension of left array </td></tr>
    <tr><td class="paramname">rightArray</td><td>Right 1D array to be convolved </td></tr>
    <tr><td class="paramname">rightDim</td><td>Dimension of right array </td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output array </td></tr>
    <tr><td class="paramname">startOffset</td><td>Skip the first startOffset terms </td></tr>
    <tr><td class="paramname">endOffset</td><td>Skip the final startOffset terms </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="array__convolution_8hpp_source.html#l00068">68</a> of file <a class="el" href="array__convolution_8hpp_source.html">array_convolution.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    {</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        T* p_output = output;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">int</span> convDim = <a class="code" href="namespaceutilities.html#a6f98453d606e7a217fbfc6235c6ae11e">GetArrayConvolution1DSize</a>(leftDim, rightDim);</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;startOffset; ++i, ++p_output)</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        {</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;            *p_output = 0;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        }</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=startOffset; i&lt;convDim-endOffset; ++i, ++p_output)</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        {</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            KahanAccumulation&lt;T&gt; accum;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            <span class="keywordtype">int</span> kernalDim = std::min(i+1, convDim-i);</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;            <span class="comment">//  If the arrays are not of equal length, then restrict the </span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            <span class="comment">//  kernal of the convolution to take this into account</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;            <span class="keywordflow">if</span>(kernalDim&gt;leftDim)  kernalDim = leftDim;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            <span class="keywordflow">if</span>(kernalDim&gt;rightDim) kernalDim = rightDim;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;            <span class="keywordflow">if</span>(rightDim&gt;i)</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            { </div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;kernalDim; ++j)</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                {</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                    accum += leftArray[j]*rightArray[j+rightDim-kernalDim];</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                }</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            }</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            {</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;kernalDim; ++j)</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                    accum += leftArray[j+i-rightDim+1]*rightArray[j];</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                }</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            }</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;            *p_output = accum.m_sum;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        }</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;endOffset; ++i, ++p_output)</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        {</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;            *p_output = 0;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        }</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_html_a6f98453d606e7a217fbfc6235c6ae11e"><div class="ttname"><a href="namespaceutilities.html#a6f98453d606e7a217fbfc6235c6ae11e">utilities::GetArrayConvolution1DSize</a></div><div class="ttdeci">int GetArrayConvolution1DSize(const int leftDim, const int rightDim)</div><div class="ttdoc">A function to calculate and return the size of the convolved array, given the lengths of the input ar...</div><div class="ttdef"><b>Definition:</b> <a href="array__convolution_8hpp_source.html#l00047">array_convolution.hpp:47</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac9c36d896506baca457165063e09ff16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename H , int P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::ArrayConvolution2D </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rightArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>leftArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dimX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dimY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>topOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>leftOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>bottomOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>rightOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A template function to emulate Mathematica's "ListCorrelate" function for arbitrary c++ data types stored in regular arrays. This version of the function treats the arrays as 2 dimensional. </p>
<p>IMPORTANT: the output array MUST be allocated with dimension given by the GetArrayConvolution2DSize function.</p>
<p>This function is equivalent to the Mathematica function:</p>
<p>ListCorrelate[rightArray,leftArray,{{dimX-topOffset,dimY-leftOffset}, {bottomOffset-dimX,rightOffset-dimY}},0]</p>
<p>where rightArray and leftArray are now indexed as 2D arrays. i.e. leftArray = {{a,b,c},{d,e,f}} etc.</p>
<p>Standard arithmetic in convolution array calcualtion is improved through the use of Kahan accumulation techniques. Alternatively, high precision variables can be set using the template parameters.</p>
<p>Template parameters: T - the type used in the convolved arrays and output H - a high precision mpc_t or mpfr_t type can be set to be used in internal arithmetic. Otherwise T and H should be the same type P - an integer specifying the precision level </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rightArray</td><td>Right 1D array to be convolved </td></tr>
    <tr><td class="paramname">leftArray</td><td>Left 1D array to be convolved </td></tr>
    <tr><td class="paramname">dimX</td><td>Array x dimension </td></tr>
    <tr><td class="paramname">dimY</td><td>Array y dimension (for simplicity assuming both arrays have the same dimensions) </td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output array </td></tr>
    <tr><td class="paramname">topOffset</td><td>Skip the first topOffset terms in each row </td></tr>
    <tr><td class="paramname">leftOffset</td><td>Skip the first leftOffset terms in each column </td></tr>
    <tr><td class="paramname">bottomOffset</td><td>Skip the last bottomOffset terms in each row </td></tr>
    <tr><td class="paramname">rightOffset</td><td>Skip the final rightOffset terms in each column </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="array__convolution_8hpp_source.html#l00151">151</a> of file <a class="el" href="array__convolution_8hpp_source.html">array_convolution.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    {</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        T* p_output = output;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">int</span> convDimX = (2*dimX - 1);</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">int</span> convDimY = (2*dimY - 1);</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;convDimX; ++i)</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        {</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;            <span class="comment">//  X-dimension of the overlap        </span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">int</span> kernalDimX = std::min(i+1, convDimX-i);</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;convDimY; ++j, ++p_output)</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;            {   </div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                <span class="keywordflow">if</span>(is_same&lt;T, H&gt;::value)</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                {</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                    KahanAccumulation&lt;T&gt; accum;</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                    <span class="comment">//  If the value is outside of the range specified by the offset parameters</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                    <span class="comment">//  then set the result to be zero</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                    <span class="keywordflow">if</span>(i&gt;= topOffset &amp;&amp; i&lt; convDimX - bottomOffset &amp;&amp; j&gt;=leftOffset &amp;&amp; j&lt; convDimY-rightOffset)</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                    {</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                        <span class="comment">//  Y-dimension of the overlap      </span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                        <span class="keyword">const</span> <span class="keywordtype">int</span> kernalDimY = std::min(j+1, convDimY-j);</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                        <span class="keywordflow">if</span>(dimX&gt;i)</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                        { </div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                            <span class="keywordflow">if</span>(dimY&gt;j)</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                            {            </div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;kernalDimX; ++x)</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                                {</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;kernalDimY; ++y)</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                                    {</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                                        accum += leftArray[x*dimY+y]*rightArray[(x+dimX-kernalDimX)*dimY+(y+dimY-kernalDimY)];</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                                    }</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                                }</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                            }</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                            {</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;kernalDimX; ++x)</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                                {</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;kernalDimY; ++y)</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                                    {</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                                        accum += leftArray[x*dimY+(y+dimY-kernalDimY)]*rightArray[(x+dimX-kernalDimX)*dimY+y];</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                                    }</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                                }</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                            }</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                        }</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                        {</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                            <span class="keywordflow">if</span>(dimY&gt;j)</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                            {            </div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;kernalDimX; ++x)</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                                {</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;kernalDimY; ++y)</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                                    {</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                                        accum += leftArray[(x+dimX-kernalDimX)*dimY+y]*rightArray[x*dimY+(y+dimY-kernalDimY)];</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                                    }</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                                }</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                            }</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                            {</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;kernalDimX; ++x)</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                                {</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;kernalDimY; ++y)</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                                    {</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                                        accum += leftArray[(x+dimX-kernalDimX)*dimY+(y+dimY-kernalDimY)]*rightArray[x*dimY+y];</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                                    }</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                                }</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                            }</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                        }</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                    }</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                    </div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                    *p_output = accum.m_sum;</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                }</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="preprocessor">                #if _ENABLE_HIGH_PRECISION_</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="preprocessor"></span>                <span class="keywordflow">else</span> <span class="keywordflow">if</span>((is_same&lt;T,dcmplx&gt;::value &amp;&amp; is_same&lt;H,mpfCmplx&gt;::value) || (is_same&lt;T,double&gt;::value &amp;&amp; is_same&lt;H,mpf_t&gt;::value))</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                {</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                    HpWrap&lt;H,P&gt; hpAccum;</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                    hpAccum.Set(0.0);</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;                    HpWrap&lt;H,P&gt; temp;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                    HpWrap&lt;H,P&gt; temp1;</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                    <span class="comment">//  If the value is outside of the range specified by the offset parameters</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                    <span class="comment">//  then set the result to be zero</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                    <span class="keywordflow">if</span>(i&gt;= topOffset &amp;&amp; i&lt; convDimX - bottomOffset &amp;&amp; j&gt;=leftOffset &amp;&amp; j&lt; convDimY-rightOffset )</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                    {</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                        <span class="comment">//  Y-dimension of the overlap      </span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                        <span class="keyword">const</span> <span class="keywordtype">int</span> kernalDimY = std::min(j+1,convDimY-j);</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;                        <span class="keywordflow">if</span>(dimX&gt;i)</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                        { </div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                            <span class="keywordflow">if</span>(dimY&gt;j)</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                            {            </div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;kernalDimX; ++x)</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                                {</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;kernalDimY; ++y)</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                                    {</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;                                        temp.Set(leftArray[x*dimY+y]);</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                                        temp1.Set(rightArray[(x+dimX-kernalDimX)*dimY+(y+dimY-kernalDimY)]);</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                                        temp *= temp1;</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                                        hpAccum += temp;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                                    }</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                                }</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                            }</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                            {</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;kernalDimX; ++x)</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;                                {</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;kernalDimY; ++y)</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                                    {</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                                        temp.Set(leftArray[x*dimY+(y+dimY-kernalDimY)]);</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                                        temp1.Set(rightArray[(x+dimX-kernalDimX)*dimY+y]);</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                                        temp *= temp1;</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                                        hpAccum += temp;</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                                    }</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                                }</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                            }</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                        }</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                        {</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                            <span class="keywordflow">if</span>(dimY&gt;j)</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                            {            </div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;kernalDimX; ++x)</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                                {</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;kernalDimY; ++y)</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                                    {</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                                        temp.Set(leftArray[(x+dimX-kernalDimX)*dimY+y]);</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                                        temp1.Set(rightArray[x*dimY+(y+dimY-kernalDimY)]);</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                                        temp *= temp1;</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                                        hpAccum += temp;</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                                    }</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                                }</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                            }</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                            {</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;kernalDimX; ++x)</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                                {</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;kernalDimY; ++y)</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                                    {</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                                        temp.Set(leftArray[(x+dimX-kernalDimX)*dimY+(y+dimY-kernalDimY)]);</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                                        temp1.Set(rightArray[x*dimY+y]);</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;                                        temp *= temp1;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                                        hpAccum += temp;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                                    }</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                                }</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                            }</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                        }</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                    }</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                    *p_output = hpAccum.Get();</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                }</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="preprocessor">                #endif</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="preprocessor"></span>                <span class="keywordflow">else</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                {</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                    std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR WITH ArrayConvolution2D - Template parameters T and H inconsistent&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                    exit(EXIT_FAILURE);</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                }</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;            }    </div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        }</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a164de456dfa80963cf9884fd0f421500"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="i__const__def_8hpp.html#ab03128f28254e912f824640e69fc85ad">I</a> utilities::BinarySearch </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="i__const__def_8hpp.html#ab03128f28254e912f824640e69fc85ad">I</a>&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a given value, determine its index with a lexicographically ordered array of values. Only the first instance is returned. </p>
<p>Binary search algorithm here taken from <a href="http://en.wikipedia.org/wiki/Binary_search_algorithm">http://en.wikipedia.org/wiki/Binary_search_algorithm</a></p>
<dl class="section return"><dt>Returns</dt><dd>The first position in the array where the value occurs</dd></dl>
<p>Return error code if unable to find the value is the maximum value of an I type given by std::numeric_limits&lt;I&gt;::max() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to find </td></tr>
    <tr><td class="paramname">array</td><td>Lexicographically ordered array </td></tr>
    <tr><td class="paramname">dim</td><td>Length of array </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="binary__search_8hpp_source.html#l00051">51</a> of file <a class="el" href="binary__search_8hpp_source.html">binary_search.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    {</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        <a class="code" href="i__const__def_8hpp.html#ab03128f28254e912f824640e69fc85ad">I</a> imax = dim - 1;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <a class="code" href="i__const__def_8hpp.html#ab03128f28254e912f824640e69fc85ad">I</a> imin = 0;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        <span class="keywordflow">if</span>(value&lt;array[imin] || value&gt;array[imax])</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        {</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            <span class="keywordflow">return</span> std::numeric_limits&lt;I&gt;::max();  <span class="comment">//  Failed to find the value</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        }</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordflow">while</span>(imax &gt;= imin)</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        {</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;            <span class="keyword">const</span> <a class="code" href="i__const__def_8hpp.html#ab03128f28254e912f824640e69fc85ad">I</a> imid = (imax+imin)/2;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            <span class="keyword">const</span> T midValue = array[imid];</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            <span class="keywordflow">if</span>(value == midValue)</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;            {</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;                <span class="keywordflow">return</span> imid; </div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;            }</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &gt; midValue)</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;            {</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                imin = imid + 1;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;            }</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            {   </div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                <span class="keywordflow">if</span>(imax==0) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                imax = imid - 1;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            }</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        }</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="keywordflow">return</span> std::numeric_limits&lt;I&gt;::max();  <span class="comment">//  Failed to find the value</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    }</div>
<div class="ttc" id="i__const__def_8hpp_html_ab03128f28254e912f824640e69fc85ad"><div class="ttname"><a href="i__const__def_8hpp.html#ab03128f28254e912f824640e69fc85ad">I</a></div><div class="ttdeci">static const std::complex&lt; double &gt; I</div><div class="ttdef"><b>Definition:</b> <a href="i__const__def_8hpp_source.html#l00014">i_const_def.hpp:14</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af6c998b8af25f017f89078615f9fd4e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="i__const__def_8hpp.html#ab03128f28254e912f824640e69fc85ad">I</a> utilities::BinarySearch </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the binary search function for std::vector arrays. </p>
<dl class="section return"><dt>Returns</dt><dd>The first position in the array where the value occurs</dd></dl>
<p>Return error code if unable to find the value is the maximum value of an I type given by std::numeric_limits&lt;I&gt;::max() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to find </td></tr>
    <tr><td class="paramname">array</td><td>Lexicographically ordered array </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="binary__search_8hpp_source.html#l00093">93</a> of file <a class="el" href="binary__search_8hpp_source.html">binary_search.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    {</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <span class="keywordflow">return</span> utilities::BinarySearch&lt;T,I&gt;(value, array.data(), (<a class="code" href="i__const__def_8hpp.html#ab03128f28254e912f824640e69fc85ad">I</a>)array.size());</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    }</div>
<div class="ttc" id="i__const__def_8hpp_html_ab03128f28254e912f824640e69fc85ad"><div class="ttname"><a href="i__const__def_8hpp.html#ab03128f28254e912f824640e69fc85ad">I</a></div><div class="ttdeci">static const std::complex&lt; double &gt; I</div><div class="ttdef"><b>Definition:</b> <a href="i__const__def_8hpp_source.html#l00014">i_const_def.hpp:14</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8a09b9ed8b3a53cb176844c576b0ce53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T utilities::Binomial </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the combinatoric factor input1 Choose input2. Inputs are double variables to avoid overflows. </p>
<dl class="section return"><dt>Returns</dt><dd>Value of binomial coefficient (output type T) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input1</td><td>First index of binomial </td></tr>
    <tr><td class="paramname">input2</td><td>Second index of binomial </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="binomials_8hpp_source.html#l00050">50</a> of file <a class="el" href="binomials_8hpp_source.html">binomials.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    {</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <span class="keywordflow">if</span>(input2&gt;input1||input2&lt;0){<span class="keywordflow">return</span> 0;}</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordflow">if</span>(input2==0)</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            <span class="keywordflow">return</span> 1;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        }</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        T cmp = 1;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        T output = 0;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <span class="keywordflow">if</span>(input1==input2){<span class="keywordflow">return</span> 1;}</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordflow">if</span>(input1&gt;input2){output=input1;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;            <span class="keywordflow">while</span> (input1-cmp&gt;input2){output*=(input1-cmp);++cmp;}}</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(input2&gt;input1){output=input2;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            <span class="keywordflow">while</span> (input2-cmp&gt;input1){output*=(input2-cmp);++cmp;}</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            output=1 / output;}</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        T in=input1-input2;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        cmp=0;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        <span class="keywordflow">while</span> (in-cmp&gt;1){output/=(in-cmp);++cmp;}</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        <span class="keywordflow">return</span> (T)round(output);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    }                                        </div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3a076d248f808f6ab243602dc157c797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int utilities::BinomialFromTable </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binomial look-up function protorype. </p>
<p>A function to address the binomial table (returns n choose k) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>First binmoial argument </td></tr>
    <tr><td class="paramname">k</td><td>Second binomial argument </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="binomials_8cpp_source.html#l00034">34</a> of file <a class="el" href="binomials_8cpp_source.html">binomials.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    {</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <span class="keywordflow">if</span>(k==n || k==0)</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        {</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;            <span class="keywordflow">return</span> 1;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        }</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(n&lt;k)</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        {</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;            <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        }</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(n&gt;<a class="code" href="namespaceutilities.html#a1a58897161c5ac004869b8f994de5ff4">maxBinomial</a> || k&gt;<a class="code" href="namespaceutilities.html#a1a58897161c5ac004869b8f994de5ff4">maxBinomial</a>)    <span class="comment">//  Beyond range stored in table</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        {</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;            <span class="keywordflow">return</span> utilities::Binomial&lt;double&gt;(n, k);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        }</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        <span class="keywordtype">int</span> tmpK = k;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        <span class="keywordflow">if</span>(k&gt;n/2)</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;            tmpK = n - tmpK;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        }</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordflow">if</span>(tmpK==1)</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            <span class="keywordflow">return</span> n;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        }</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        {</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">int</span> tmp = n/2 - 2;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespaceutilities.html#ae923787d35bb2fff3ded45e174f1756c">binomialLookUpTable</a>[((n &amp; 1) + tmp)*(tmp+1)+(tmpK-2)];</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        }</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_html_ae923787d35bb2fff3ded45e174f1756c"><div class="ttname"><a href="namespaceutilities.html#ae923787d35bb2fff3ded45e174f1756c">utilities::binomialLookUpTable</a></div><div class="ttdeci">static const long int binomialLookUpTable[]</div><div class="ttdef"><b>Definition:</b> <a href="binomials_8hpp_source.html#l00088">binomials.hpp:88</a></div></div>
<div class="ttc" id="namespaceutilities_html_a1a58897161c5ac004869b8f994de5ff4"><div class="ttname"><a href="namespaceutilities.html#a1a58897161c5ac004869b8f994de5ff4">utilities::maxBinomial</a></div><div class="ttdeci">static const int maxBinomial</div><div class="ttdef"><b>Definition:</b> <a href="binomials_8hpp_source.html#l00039">binomials.hpp:39</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab535008cab9192c3da1bbca22e841f38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::DiscreteFourierTransform1D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a series of 1D discrete Fourier transforms. </p>
<p>Y_{j,m} = sum_n=1^N exp^{sign*2*I*PI*n*j/N} X_{n,m} </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Dimension of the sum in the transform </td></tr>
    <tr><td class="paramname">M</td><td>Number of independent transforms performed in one function call </td></tr>
    <tr><td class="paramname">inputs</td><td>Array of Fourier coefficients for each transform Must be of dimension N*M </td></tr>
    <tr><td class="paramname">outputs</td><td>Array to contain the output data. Must be of dimension N*M </td></tr>
    <tr><td class="paramname">sign</td><td>Set the sign of the transform as either FFTW_BACKWARD (+1) or FFTW_FORWARD (-1) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fftw__wrapper_8cpp_source.html#l00036">36</a> of file <a class="el" href="fftw__wrapper_8cpp_source.html">fftw_wrapper.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    {</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        fftw_complex *in, *out;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        fftw_plan plan = 0;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        in  = (fftw_complex*) fftw_malloc(<span class="keyword">sizeof</span>(fftw_complex)*N);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        out = (fftw_complex*) fftw_malloc(<span class="keyword">sizeof</span>(fftw_complex)*N);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m=0; m&lt;M; ++m)</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;            plan = fftw_plan_dft_1d(N, in, out, sign, FFTW_PATIENT);</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n=0; n&lt;N; ++n)</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;            {</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                in[n][0] = std::real(inputs[m*N+n]);</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                in[n][1] = std::imag(inputs[m*N+n]);</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            }</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            fftw_execute(plan);</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n=0; n&lt;N; ++n)</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            {</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                outputs[m*N+n] = <a class="code" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a>(out[n][0], out[n][1]);</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            }</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        }</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        fftw_destroy_plan(plan);</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        fftw_free(in);</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        fftw_free(out);</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    }</div>
<div class="ttc" id="dcmplx__type__def_8hpp_html_a52196b4b274b585226e0614490f7defc"><div class="ttname"><a href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a></div><div class="ttdeci">std::complex&lt; double &gt; dcmplx</div><div class="ttdef"><b>Definition:</b> <a href="dcmplx__type__def_8hpp_source.html#l00014">dcmplx_type_def.hpp:14</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9af9c3d98c2afbb6d16e02fa26806e4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , order_t O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::DoQuickSort </td>
          <td>(</td>
          <td class="paramtype">K *&#160;</td>
          <td class="paramname"><em>keyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>valueList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>nSort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>maxSorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts keys and values lists according to the keys list. Returns after the first nSort elements are sorted. Sorting is performed with an in-place quick sort algorithm, with the pivot chosen as the median of the first, middle and last element of the partition. </p>
<p>Template arguments: K: key data type, used for sorting V: value data type, not used for sorting O: Select from <em>ASCENDING_ORDER</em> or <em>DESCENDING_ORDER</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyList</td><td>Address of sort key list </td></tr>
    <tr><td class="paramname">valueList</td><td>Address of value list </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of list </td></tr>
    <tr><td class="paramname">nSort</td><td>Number of elements to sort before returning </td></tr>
    <tr><td class="paramname">maxSorted</td><td>The value up to which the algorithm has now sorted the input arrays </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00189">189</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    {</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        <span class="keywordflow">if</span>(dim==0 || dim==1)  <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        <span class="keywordflow">if</span>(maxSorted&gt;nSort)    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        K* p_keyFirst  = keyList;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        K* p_keyMiddle = keyList+dim/2;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        K* p_keyLast   = keyList+dim-1;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        {</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            V* p_valueFirst  = valueList;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            V* p_valueMiddle = valueList+dim/2;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;            V* p_valueLast   = valueList+dim-1;</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;            <span class="keywordflow">if</span>(Compare&lt;K,O&gt;::Value(p_keyLast, p_keyMiddle))</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;            {</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_keyLast, p_keyMiddle);</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_valueLast, p_valueMiddle);</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            }</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            <span class="keywordflow">if</span>(Compare&lt;K,O&gt;::Value(p_keyMiddle, p_keyFirst))</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;            {</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_keyMiddle, p_keyFirst);</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_valueMiddle, p_valueFirst);</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            }</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;            <span class="keywordflow">if</span>(Compare&lt;K,O&gt;::Value(p_keyLast, p_keyMiddle))</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            {</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_keyLast, p_keyMiddle);</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_valueLast, p_valueMiddle);</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            }</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        }</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        <span class="keywordflow">if</span>(dim==2 || dim==3)</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        {</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;            maxSorted += dim;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        }</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        K pivot = *p_keyMiddle;</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        K* p_keyLeft   = keyList;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        V* p_valueLeft = valueList;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        K* p_keyRight   = keyList+dim-1;</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        V* p_valueRight = valueList+dim-1;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> partitionSize = dim; </div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        <span class="keywordflow">while</span>(p_keyRight &gt; p_keyLeft)</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        {</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;            <span class="keywordflow">while</span>(Compare&lt;K,O&gt;::Value(p_keyLeft, &amp;pivot) &amp;&amp; p_keyLeft &lt; p_keyLast)</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;            {</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                p_keyLeft++;</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                p_valueLeft++;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;            }</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;            </div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            <span class="keywordflow">while</span>(Compare&lt;K,O&gt;::Value(&amp;pivot, p_keyRight) &amp;&amp; p_keyRight &gt; p_keyFirst)</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            {</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                p_keyRight--;</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                p_valueRight--;</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                partitionSize--;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;            }</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            <span class="keywordflow">if</span>(p_keyRight &gt; p_keyLeft)</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;            {</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_keyRight, p_keyLeft);</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_valueRight, p_valueLeft);</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            }</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        }</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;        DoQuickSort&lt;K, V, O&gt;(keyList, valueList, partitionSize, nSort, maxSorted);</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;        DoQuickSort&lt;K, V, O&gt;(keyList+partitionSize, valueList+partitionSize, dim-partitionSize, nSort,maxSorted);</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    };</div>
<div class="ttc" id="namespaceutilities_html_aa4186e485e8332d7bdeca00b7ce89cc6"><div class="ttname"><a href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">utilities::Swap</a></div><div class="ttdeci">void Swap(T *&amp;a, T *&amp;b)</div><div class="ttdoc">A template for a swap function, to swap the contents of two memory addresses. This version is used as...</div><div class="ttdef"><b>Definition:</b> <a href="quick__sort_8hpp_source.html#l00169">quick_sort.hpp:169</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af9bfadc2924da9f8a04e10c6a72a4891"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t utilities::Evaluate_CCd </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>coefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>k1Occupied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>k2Occupied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>highestOrbital</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply an operator c_k1 c^+_k2 to a given state. </p>
<p>NOTE: the states are assumed to be written in ascending order of orbital labels</p>
<p>NOTE: this implementation assumes a 64-bit architecture</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the final state. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coefficient</td><td>Address to store the sign of the output state </td></tr>
    <tr><td class="paramname">k1Occupied</td><td>First orbital occupied </td></tr>
    <tr><td class="paramname">k2Occupied</td><td>Second orbital occupied </td></tr>
    <tr><td class="paramname">state</td><td>The state to be operated on </td></tr>
    <tr><td class="paramname">highestOrbital</td><td>Highest possible orbital </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fermions_8hpp_source.html#l00238">238</a> of file <a class="el" href="fermions_8hpp_source.html">fermions.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    {</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        <span class="comment">//  Store the following results for subsequent use. These values store</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <span class="comment">//  e.g. ...00000010000...</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;        <span class="comment">//                ^ - corresponds to the k1 or k2 orbital </span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        <span class="comment">//  Note that we denote ...0001 as the 0th orbital</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        <span class="comment">//  Check conditions for which the result will be zero</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        <span class="comment">//  NOTE: lowest state is const static uint64_t 1</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        <span class="keywordflow">if</span>( </div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        (k2Occupied&gt;highestOrbital)  <span class="comment">//  Orbitals higher than highestOrbital are not occupied                                               </span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        || ((state &amp; k2Occupied)!=0) <span class="comment">//  If the state already contains k2</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                                     <span class="comment">//  then c^+_k2 acts to give zero </span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        )</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;        {   </div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            coefficient = 0;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            <span class="keywordflow">return</span> 0;    <span class="comment">//  Default return, but it won&#39;t be used   </span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;        }</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;        <span class="comment">//  If the input state is not zero then the output state is related to </span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        <span class="comment">//  it by a simple set of bitshift operations.</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        <span class="comment">//  We also need to keep track of the sign of the output state</span></div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        <span class="keywordflow">if</span>(k1Occupied &amp; k2Occupied)</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        {</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            <span class="comment">//  In this case the output state is the same as the input state</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            <span class="comment">//  and the sign is always positive</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            coefficient = 1;</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            <span class="keywordflow">return</span> state;</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        }</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        uint64_t outState = state;</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        uint64_t maskedState;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        <span class="comment">//  First add the k2 orbital to the state</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        <span class="comment">//  Mask all occupations to the right of k2 </span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        maskedState = outState &amp; (k2Occupied-1);</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;        <span class="comment">//  Count the number of bits in the remaining state</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="preprocessor">        #if _USING_ITERATIVE_HAMMING_WEIGHT_ALGORITHM_</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="preprocessor"></span>            coefficient = <a class="code" href="namespaceutilities_1_1binary.html#a96d8b45e953aaeda9a4e6c6ee5e2086d">utilities::binary::HammingWeight64Iterative</a>(maskedState);</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="preprocessor">        #else</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="preprocessor"></span>            coefficient = <a class="code" href="namespaceutilities_1_1binary.html#a067057e4bb4d8570a644f35f3cf0b88f">utilities::binary::HammingWeight64</a>(maskedState);</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="preprocessor">        #endif</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="preprocessor"></span>        <span class="comment">//  Add the k2 orbital to the state (with bitwise OR)</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;        outState = outState | k2Occupied;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        <span class="comment">//  Next commute the k1 operator through the state. We can commute through</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        <span class="comment">//  until we reach the orbital labelled by k1</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        <span class="comment">//  Mask all occupations to the right of k1</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;        maskedState = outState &amp; (k1Occupied-1);</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;        <span class="comment">//  Then simply count the number of of non-zero bits in that result and see </span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        <span class="comment">//  if the number is even or odd at the end</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="preprocessor">        #if _USING_ITERATIVE_HAMMING_WEIGHT_ALGORITHM_</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="preprocessor"></span>            coefficient += <a class="code" href="namespaceutilities_1_1binary.html#a96d8b45e953aaeda9a4e6c6ee5e2086d">utilities::binary::HammingWeight64Iterative</a>(maskedState);</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="preprocessor">        #else</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="preprocessor"></span>            coefficient += <a class="code" href="namespaceutilities_1_1binary.html#a067057e4bb4d8570a644f35f3cf0b88f">utilities::binary::HammingWeight64</a>(maskedState);</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="preprocessor">        #endif</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="preprocessor"></span>        <span class="comment">//  Remove the k1 orbital from the state (with bitwise XOR), </span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        <span class="comment">//  since it&#39;s been annihilated</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        outState ^= k1Occupied;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;         <span class="comment">//  Convert our coefficient into a + or - sign only. </span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        <span class="keywordflow">if</span>(coefficient &amp; 1)</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        {</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            coefficient = -1;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        }</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        {</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            coefficient = +1;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        }</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        <span class="keywordflow">return</span> outState;</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_1_1binary_html_a067057e4bb4d8570a644f35f3cf0b88f"><div class="ttname"><a href="namespaceutilities_1_1binary.html#a067057e4bb4d8570a644f35f3cf0b88f">utilities::binary::HammingWeight64</a></div><div class="ttdeci">int HammingWeight64(uint64_t x)</div><div class="ttdoc">Hamming weight algorithm with minimal number of arithmetic operations. </div><div class="ttdef"><b>Definition:</b> <a href="binary__number__tools_8cpp_source.html#l00095">binary_number_tools.cpp:95</a></div></div>
<div class="ttc" id="namespaceutilities_1_1binary_html_a96d8b45e953aaeda9a4e6c6ee5e2086d"><div class="ttname"><a href="namespaceutilities_1_1binary.html#a96d8b45e953aaeda9a4e6c6ee5e2086d">utilities::binary::HammingWeight64Iterative</a></div><div class="ttdeci">int HammingWeight64Iterative(uint64_t x)</div><div class="ttdoc">Iterative Hamming weight algorithm. </div><div class="ttdef"><b>Definition:</b> <a href="binary__number__tools_8cpp_source.html#l00137">binary_number_tools.cpp:137</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a54074ad1aa43454e68e44d9a5d5cf349"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t utilities::Evaluate_CdC </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>coefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>k1Occupied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>k2Occupied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>highestOrbital</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply an operator c^+_k1 c_k2 to a given state. </p>
<p>NOTE: the states are assumed to be written in ascending order of orbital labels</p>
<p>NOTE: this implementation assumes a 64-bit architecture</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the final state. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coefficient</td><td>Address to store the sign of the output state </td></tr>
    <tr><td class="paramname">k1Occupied</td><td>First orbital occupied </td></tr>
    <tr><td class="paramname">k2Occupied</td><td>Second orbital occupied </td></tr>
    <tr><td class="paramname">state</td><td>The state to be operated on </td></tr>
    <tr><td class="paramname">highestOrbital</td><td>Highest possible orbital </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fermions_8hpp_source.html#l00155">155</a> of file <a class="el" href="fermions_8hpp_source.html">fermions.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    {</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        <span class="comment">//  Store the following results for subsequent use. These values store</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        <span class="comment">//  e.g. ...00000010000...</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="comment">//                ^ - corresponds to the k1 or k2 orbital </span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        <span class="comment">//  Note that we denote ...0001 as the 0th orbital</span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        <span class="comment">//  Check conditions for which the result will be zero</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        <span class="comment">//  NOTE: lowest state is const static uint64_t 1</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        <span class="keywordflow">if</span>(</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        (k2Occupied&gt;highestOrbital)  <span class="comment">//  Orbitals higher than highestOrbital are not occupied                                               </span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        || ((state &amp; k2Occupied)==0) <span class="comment">//  If the state does not already contain k2</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                                     <span class="comment">//  then c_k2 acts to give zero </span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        || (!(k1Occupied &amp; k2Occupied) &amp;&amp; (state &amp; k1Occupied)!=0) <span class="comment">//    If the c^+_k1 acts on an identical</span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                                     <span class="comment">//  state then we get zero, unless k1 and k2 are equal</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        )</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        {   </div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            coefficient = 0;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;            <span class="keywordflow">return</span> 0;    <span class="comment">//  Default return, but it won&#39;t be used   </span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        }</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        <span class="comment">//  If the input state is not zero then the output state is related to </span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        <span class="comment">//  it by a simple set of bitshift operations.</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        <span class="comment">//  We also need to keep track of the sign of the output state</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        <span class="keywordflow">if</span>(k1Occupied &amp; k2Occupied)</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            <span class="comment">//  In this case the output state is the same as the input state</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;            <span class="comment">//  and the sign is always positive</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;            coefficient = 1;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            <span class="keywordflow">return</span> state;</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        }</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        uint64_t outState;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        uint64_t maskedState;</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        <span class="comment">//  First commute the k2 operator through the state. We can commute through</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        <span class="comment">//  until we reach the orbital labelled by k2</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        <span class="comment">//  Mask all occupations to the right of k2</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        maskedState = state &amp; (k2Occupied-1);</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        <span class="comment">//  Then simply count the number of of non-zero bits in that result and see </span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <span class="comment">//  if the number is even or odd at the end</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="preprocessor">        #if _USING_ITERATIVE_HAMMING_WEIGHT_ALGORITHM_</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="preprocessor"></span>            coefficient = <a class="code" href="namespaceutilities_1_1binary.html#a96d8b45e953aaeda9a4e6c6ee5e2086d">utilities::binary::HammingWeight64Iterative</a>(maskedState);</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="preprocessor">        #else</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="preprocessor"></span>            coefficient = <a class="code" href="namespaceutilities_1_1binary.html#a067057e4bb4d8570a644f35f3cf0b88f">utilities::binary::HammingWeight64</a>(maskedState);</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="preprocessor">        #endif</span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="preprocessor"></span>        <span class="comment">//  Remove the k2 orbital from the state (with bitwise XOR), </span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        <span class="comment">//  since it&#39;s been annihilated</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        outState = state ^ k2Occupied;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        <span class="comment">//  We generate the final state by adding in the k1 labelled</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        <span class="comment">//  creation operator. </span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        <span class="comment">//  Mask all occupations to the right of k1 </span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        maskedState = outState &amp; (k1Occupied-1);</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        <span class="comment">//  Count the number of bits in the remaining state</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="preprocessor">        #if _USING_ITERATIVE_HAMMING_WEIGHT_ALGORITHM_</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="preprocessor"></span>            coefficient += <a class="code" href="namespaceutilities_1_1binary.html#a96d8b45e953aaeda9a4e6c6ee5e2086d">utilities::binary::HammingWeight64Iterative</a>(maskedState);</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="preprocessor">        #else</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="preprocessor"></span>            coefficient += <a class="code" href="namespaceutilities_1_1binary.html#a067057e4bb4d8570a644f35f3cf0b88f">utilities::binary::HammingWeight64</a>(maskedState);</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="preprocessor">        #endif</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="preprocessor"></span>        <span class="comment">//  Add the k1 orbital to the state (with bitwise OR)</span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        outState = outState | k1Occupied;</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;         <span class="comment">//  Convert our coefficient into a + or - sign only. </span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        <span class="keywordflow">if</span>(coefficient &amp; 1)</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        {</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            coefficient = -1;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        }</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        {</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            coefficient = +1;</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        }</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        <span class="keywordflow">return</span> outState;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_1_1binary_html_a067057e4bb4d8570a644f35f3cf0b88f"><div class="ttname"><a href="namespaceutilities_1_1binary.html#a067057e4bb4d8570a644f35f3cf0b88f">utilities::binary::HammingWeight64</a></div><div class="ttdeci">int HammingWeight64(uint64_t x)</div><div class="ttdoc">Hamming weight algorithm with minimal number of arithmetic operations. </div><div class="ttdef"><b>Definition:</b> <a href="binary__number__tools_8cpp_source.html#l00095">binary_number_tools.cpp:95</a></div></div>
<div class="ttc" id="namespaceutilities_1_1binary_html_a96d8b45e953aaeda9a4e6c6ee5e2086d"><div class="ttname"><a href="namespaceutilities_1_1binary.html#a96d8b45e953aaeda9a4e6c6ee5e2086d">utilities::binary::HammingWeight64Iterative</a></div><div class="ttdeci">int HammingWeight64Iterative(uint64_t x)</div><div class="ttdoc">Iterative Hamming weight algorithm. </div><div class="ttdef"><b>Definition:</b> <a href="binary__number__tools_8cpp_source.html#l00137">binary_number_tools.cpp:137</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4525c2d723469d4a1738b867459aeb84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t utilities::Evaluate_CdCdCC </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>coefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>k1Occupied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>k2Occupied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>k3Occupied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>k4Occupied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>highestOrbital</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply an operator c^+_k1 c^+_k2 c_k3 c_k4 to a given state (with k1+k2=k3+k4) </p>
<p>There will be only one possible resulting state since we are dealing with fermions (bosons is more complicated, since in that case there can be multiple final states).</p>
<p>NOTE: the states are assumed to be written in ascending order of orbital labels</p>
<p>NOTE: this implementation assumes a 64-bit architecture</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the final state. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coefficient</td><td>Address to store the sign of the output state </td></tr>
    <tr><td class="paramname">k1Occupied</td><td>State with first orbital index occupied </td></tr>
    <tr><td class="paramname">k2Occupied</td><td>State with second orbital index occupied </td></tr>
    <tr><td class="paramname">k3Occupied</td><td>State with third orbital index occupied </td></tr>
    <tr><td class="paramname">k4Occupied</td><td>State with fourth orbital index occupied </td></tr>
    <tr><td class="paramname">state</td><td>The state to be operated on </td></tr>
    <tr><td class="paramname">highestOrbital</td><td>Highest possible orbital </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fermions_8hpp_source.html#l00052">52</a> of file <a class="el" href="fermions_8hpp_source.html">fermions.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    {</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <span class="comment">//  Store the following results for subsequent use. These values store</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="comment">//  e.g. ...00000010000...</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        <span class="comment">//                ^ - corresponds to the k1,k2,k3 or k4 orbital</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="comment">//  Note that we denote ...0001 as the 0th orbital</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        <span class="keywordflow">if</span>( </div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        (k3Occupied&gt;highestOrbital)         <span class="comment">//  Orbitals higher than highestOrbital are   </span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        || (k4Occupied&gt;highestOrbital)      <span class="comment">//  not occupied                                               </span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        || ((state &amp; k3Occupied)==0)        <span class="comment">//  If the state does not already contain </span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        || ((state &amp; k4Occupied)==0)        <span class="comment">//  both a k3 and k4 orbitals then c_k3 c_k4</span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                                            <span class="comment">//  acts to give zero </span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        || (k1Occupied &amp; k2Occupied) ||  (k3Occupied &amp; k4Occupied)     <span class="comment">//  If a c or c^+ is repeated, then we get zero</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        || (!(k1Occupied &amp; k3Occupied) &amp;&amp; !(k1Occupied &amp; k4Occupied) &amp;&amp; ((state &amp; k1Occupied)!=0))   <span class="comment">// If c^+_k1 c^+_k2 appears it vanishes, </span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        || (!(k2Occupied &amp; k3Occupied) &amp;&amp; !(k2Occupied &amp; k4Occupied) &amp;&amp; ((state &amp; k2Occupied)!=0))   <span class="comment">// but only if k1!=k3 or k4 and k2!=k3 or k4. </span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        )</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        {   </div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            coefficient = 0;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            <span class="keywordflow">return</span> 0;    <span class="comment">//  Default return, but it won&#39;t be used   </span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        }</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        <span class="comment">//  If the input state is not zero then the output state is related to </span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="comment">//  it by a simple set of bitshift operations.</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        <span class="comment">//  We also need to keep track of the sign of the output state</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        uint64_t outState;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        uint64_t maskedState;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <span class="comment">//  First commute the k4 operator through the state. We can commute through</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        <span class="comment">//  until we reach the orbital labelled by k4</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        <span class="comment">//  Mask all occupations to the right of k4</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        maskedState = state &amp; (k4Occupied-1);</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="comment">//  e.g. if the state is 101001010 and the k4 orbital (in 0,1,2,3,...) is number </span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        <span class="comment">//  3 then we mask with  000000111 and obtain 000000010. </span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="comment">//  Then simply count the number of of non-zero bits in that result and see </span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="comment">//  if the number is even or odd at the end</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="preprocessor">        #if _USING_ITERATIVE_HAMMING_WEIGHT_ALGORITHM_</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="preprocessor"></span>            coefficient = <a class="code" href="namespaceutilities_1_1binary.html#a96d8b45e953aaeda9a4e6c6ee5e2086d">utilities::binary::HammingWeight64Iterative</a>(maskedState);</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="preprocessor">        #else</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="preprocessor"></span>            coefficient = <a class="code" href="namespaceutilities_1_1binary.html#a067057e4bb4d8570a644f35f3cf0b88f">utilities::binary::HammingWeight64</a>(maskedState);</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="preprocessor">        #endif</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="preprocessor"></span>        <span class="comment">//  Remove the k4 orbital from the state (with bitwise XOR), </span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        <span class="comment">//  since it&#39;s been annihilated</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        outState = state ^ k4Occupied;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <span class="comment">//  Next we commute the k3 operator through the remaining state</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        maskedState = outState &amp; (k3Occupied-1);</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="preprocessor">        #if _USING_ITERATIVE_HAMMING_WEIGHT_ALGORITHM_</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="preprocessor"></span>            coefficient += <a class="code" href="namespaceutilities_1_1binary.html#a96d8b45e953aaeda9a4e6c6ee5e2086d">utilities::binary::HammingWeight64Iterative</a>(maskedState);</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="preprocessor">        #else</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="preprocessor"></span>            coefficient += <a class="code" href="namespaceutilities_1_1binary.html#a067057e4bb4d8570a644f35f3cf0b88f">utilities::binary::HammingWeight64</a>(maskedState);</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="preprocessor">        #endif</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="preprocessor"></span>        <span class="comment">//  Annihilate the k3 orbital to produce the output state (with bitwise XOR)</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        outState = outState ^ k3Occupied;   </div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        <span class="comment">//  We generate the final state by adding in the k1 and k2 labelled</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        <span class="comment">//  creation operators. We add k2 first (because it&#39;s to the right of k1), </span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        <span class="comment">//  then k1 afterwards. The procedure is (almost) identical to the one for</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="comment">//  k3 and k4 used above</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        <span class="comment">//  Mask all occupations to the right of k2 </span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        maskedState = outState &amp; (k2Occupied-1);</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="comment">//  Count the number of bits in the remaining state</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="preprocessor">        #if _USING_ITERATIVE_HAMMING_WEIGHT_ALGORITHM_</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="preprocessor"></span>            coefficient += <a class="code" href="namespaceutilities_1_1binary.html#a96d8b45e953aaeda9a4e6c6ee5e2086d">utilities::binary::HammingWeight64Iterative</a>(maskedState);</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="preprocessor">        #else</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="preprocessor"></span>            coefficient += <a class="code" href="namespaceutilities_1_1binary.html#a067057e4bb4d8570a644f35f3cf0b88f">utilities::binary::HammingWeight64</a>(maskedState);</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="preprocessor">        #endif</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="preprocessor"></span>        <span class="comment">//  Add the k2 orbital to the state (with bitwise OR)</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        outState = outState | k2Occupied;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        <span class="comment">//  Finally, add in k1</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        <span class="comment">//  Mask all occupations to the right of k1</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        maskedState = outState &amp; (k1Occupied-1);</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="comment">//  Count the number of bits in the remaining state</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="preprocessor">        #if _USING_ITERATIVE_HAMMING_WEIGHT_ALGORITHM_</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="preprocessor"></span>            coefficient += <a class="code" href="namespaceutilities_1_1binary.html#a96d8b45e953aaeda9a4e6c6ee5e2086d">utilities::binary::HammingWeight64Iterative</a>(maskedState); </div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="preprocessor">        #else</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="preprocessor"></span>            coefficient += <a class="code" href="namespaceutilities_1_1binary.html#a067057e4bb4d8570a644f35f3cf0b88f">utilities::binary::HammingWeight64</a>(maskedState);</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="preprocessor">        #endif</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="preprocessor"></span>        <span class="comment">//  Add the k1 orbital to the state (with bitwise OR)</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        outState = outState | k1Occupied;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        <span class="comment">//  Convert our coefficient into a + or - sign only. </span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        <span class="keywordflow">if</span>(coefficient &amp; 1)</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        {</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;            coefficient = -1;</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        }</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        {</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;            coefficient = +1;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        }</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        <span class="keywordflow">return</span>  outState;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_1_1binary_html_a067057e4bb4d8570a644f35f3cf0b88f"><div class="ttname"><a href="namespaceutilities_1_1binary.html#a067057e4bb4d8570a644f35f3cf0b88f">utilities::binary::HammingWeight64</a></div><div class="ttdeci">int HammingWeight64(uint64_t x)</div><div class="ttdoc">Hamming weight algorithm with minimal number of arithmetic operations. </div><div class="ttdef"><b>Definition:</b> <a href="binary__number__tools_8cpp_source.html#l00095">binary_number_tools.cpp:95</a></div></div>
<div class="ttc" id="namespaceutilities_1_1binary_html_a96d8b45e953aaeda9a4e6c6ee5e2086d"><div class="ttname"><a href="namespaceutilities_1_1binary.html#a96d8b45e953aaeda9a4e6c6ee5e2086d">utilities::binary::HammingWeight64Iterative</a></div><div class="ttdeci">int HammingWeight64Iterative(uint64_t x)</div><div class="ttdoc">Iterative Hamming weight algorithm. </div><div class="ttdef"><b>Definition:</b> <a href="binary__number__tools_8cpp_source.html#l00137">binary_number_tools.cpp:137</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2a6afaf89e9c2b614a690c5bae5ea984"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::FromStream </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read variable from a stream </p>

<p>Definition at line <a class="el" href="io__wrapper_8hpp_source.html#l00097">97</a> of file <a class="el" href="io__wrapper_8hpp_source.html">io_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    {</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        stream &gt;&gt; value;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6a6e06d2f7e1c9919a80f6a4328396d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::FromStream </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short unsigned int &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read variable from a stream </p>

<p>Definition at line <a class="el" href="io__wrapper_8hpp_source.html#l00105">105</a> of file <a class="el" href="io__wrapper_8hpp_source.html">io_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    {</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        stream &gt;&gt; value;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a80c64c8f0bb89708c40710bc4af5e5e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::FromStream </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of FromStream deals with dcomplx types </p>

<p>Definition at line <a class="el" href="io__wrapper_8hpp_source.html#l00113">113</a> of file <a class="el" href="io__wrapper_8hpp_source.html">io_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    {</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="keywordtype">double</span> re, im;</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        stream &gt;&gt; re &gt;&gt; im;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        value = std::complex&lt;double&gt;(re, im);</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a85f6e5cd6f08f4e47e1a00c3ebebc827"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::GenFileStream </td>
          <td>(</td>
          <td class="paramtype">F &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceio.html#a21deb8bdc22417a8eb07113769d6c601">io::fileFormat_t</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structutilities_1_1MpiWrapper.html">utilities::MpiWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper around file stream opening checks </p>

<p>Definition at line <a class="el" href="io__wrapper_8hpp_source.html#l00035">35</a> of file <a class="el" href="io__wrapper_8hpp_source.html">io_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    {</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="namespaceio.html#a21deb8bdc22417a8eb07113769d6c601af3e653b8bd8f794975fa5bda0a927bfc">io::_BINARY_</a> == format)</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        {</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;F, std::ifstream&gt;::value</a>)</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;            {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;                stream.open(fileName.c_str(), std::ios::in | std::ios::binary);</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;            }</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;F, std::ofstream&gt;::value</a>)</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;            {</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                stream.open(fileName.c_str(), std::ios::out | std::ios::binary);</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;            }</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        }</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="namespaceio.html#a21deb8bdc22417a8eb07113769d6c601ac78d869c7c1c4a0f9c801afc7cca4ce8">io::_TEXT_</a> == format)</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        {</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;F, std::ifstream&gt;::value</a>)</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;            {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                stream.open(fileName.c_str(), std::ios::in);</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;            }</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;F, std::ofstream&gt;::value</a>)</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;            {</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                stream.open(fileName.c_str(), std::ios::out);</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            }</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        }</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        {</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;            std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown file format &quot;</span> &lt;&lt; format &lt;&lt; std::endl;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            mpi.<a class="code" href="structutilities_1_1MpiWrapper.html#a7ffe7ed2049a6b7feb5778886a0d522e">m_exitFlag</a>=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        }</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordflow">if</span>(!mpi.<a class="code" href="structutilities_1_1MpiWrapper.html#a7ffe7ed2049a6b7feb5778886a0d522e">m_exitFlag</a> &amp;&amp; !stream.is_open())</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            std::cerr &lt;&lt; <span class="stringliteral">&quot;Could not open file &quot;</span> &lt;&lt; fileName &lt;&lt; std::endl;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;            mpi.<a class="code" href="structutilities_1_1MpiWrapper.html#a7ffe7ed2049a6b7feb5778886a0d522e">m_exitFlag</a>=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        }</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    }</div>
<div class="ttc" id="namespaceio_html_a21deb8bdc22417a8eb07113769d6c601af3e653b8bd8f794975fa5bda0a927bfc"><div class="ttname"><a href="namespaceio.html#a21deb8bdc22417a8eb07113769d6c601af3e653b8bd8f794975fa5bda0a927bfc">io::_BINARY_</a></div><div class="ttdef"><b>Definition:</b> <a href="io__wrapper_8hpp_source.html#l00023">io_wrapper.hpp:23</a></div></div>
<div class="ttc" id="namespaceio_html_a21deb8bdc22417a8eb07113769d6c601ac78d869c7c1c4a0f9c801afc7cca4ce8"><div class="ttname"><a href="namespaceio.html#a21deb8bdc22417a8eb07113769d6c601ac78d869c7c1c4a0f9c801afc7cca4ce8">io::_TEXT_</a></div><div class="ttdef"><b>Definition:</b> <a href="io__wrapper_8hpp_source.html#l00023">io_wrapper.hpp:23</a></div></div>
<div class="ttc" id="structutilities_1_1MpiWrapper_html_a7ffe7ed2049a6b7feb5778886a0d522e"><div class="ttname"><a href="structutilities_1_1MpiWrapper.html#a7ffe7ed2049a6b7feb5778886a0d522e">utilities::MpiWrapper::m_exitFlag</a></div><div class="ttdeci">bool m_exitFlag</div><div class="ttdef"><b>Definition:</b> <a href="mpi__wrapper_8hpp_source.html#l00067">mpi_wrapper.hpp:67</a></div></div>
<div class="ttc" id="structutilities_1_1is__same_html"><div class="ttname"><a href="structutilities_1_1is__same.html">utilities::is_same</a></div><div class="ttdoc">A template to check that two types are the same (as implemented by the function std::is_same in C++11...</div><div class="ttdef"><b>Definition:</b> <a href="template__tools_8hpp_source.html#l00038">template_tools.hpp:38</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6f98453d606e7a217fbfc6235c6ae11e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int utilities::GetArrayConvolution1DSize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>leftDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>rightDim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A function to calculate and return the size of the convolved array, given the lengths of the input arrays and treating them as 1D arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftDim</td><td>Dimension of left array </td></tr>
    <tr><td class="paramname">rightDim</td><td>Dimension of right array </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="array__convolution_8hpp_source.html#l00047">47</a> of file <a class="el" href="array__convolution_8hpp_source.html">array_convolution.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    {</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        <span class="keywordflow">return</span> leftDim + rightDim - 1;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4eb24afa4763ddf0b9128ae145f0a115"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int utilities::GetArrayConvolution2DSize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dimX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dimY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A function to calculate and return the size of the convolved array, given the lengths of the input arrays and treating them as 2D arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimX</td><td>Array x dimension </td></tr>
    <tr><td class="paramname">dimY</td><td>Array y dimension </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="array__convolution_8hpp_source.html#l00117">117</a> of file <a class="el" href="array__convolution_8hpp_source.html">array_convolution.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    {</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        <span class="keywordflow">return</span> (2*dimY - 1)*(2*dimX - 1);</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0a4e0749cf92abf92f2b0290ae0639a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::GetOption </td>
          <td>(</td>
          <td class="paramtype">boost::program_options::variables_map *&#160;</td>
          <td class="paramname"><em>variables_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper around program options parser </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables_map</td><td>Pointer to map of command line variables </td></tr>
    <tr><td class="paramname">variable</td><td>Address where variable will be stored </td></tr>
    <tr><td class="paramname">name</td><td>Name of variable to be used </td></tr>
    <tr><td class="paramname">location</td><td>Location of the function call </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="program__options__wrapper_8hpp_source.html#l00043">43</a> of file <a class="el" href="program__options__wrapper_8hpp_source.html">program_options_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    {</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="keywordflow">try</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        {</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;            variable = (*variables_map)[name].as&lt;T&gt;();</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        }</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <span class="keywordflow">catch</span>(boost::exception_detail::clone_impl&lt;boost::exception_detail::error_info_injector&lt;boost::bad_any_cast&gt; &gt;&amp; e)</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        {</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;            std::cerr &lt;&lt; <span class="stringliteral">&quot;\n\tERROR Option &quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot; queried from variables_map incorrectly in &quot;</span>;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;            std::cerr &lt;&lt; location  &lt;&lt; std::endl;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            exit(EXIT_FAILURE);</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        }</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af912b9c930103dc57531d1d9b997d27a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::GetOption </td>
          <td>(</td>
          <td class="paramtype">boost::program_options::variables_map *&#160;</td>
          <td class="paramname"><em>variables_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structutilities_1_1MpiWrapper.html">utilities::MpiWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper around program options parser (including action in parallel implementaion) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables_map</td><td>Pointer to map of command line variables </td></tr>
    <tr><td class="paramname">variable</td><td>Address where variable will be stored </td></tr>
    <tr><td class="paramname">name</td><td>Name of variable to be used </td></tr>
    <tr><td class="paramname">location</td><td>Location of the function call </td></tr>
    <tr><td class="paramname">mpi</td><td>Address of mpi wrapper </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="program__options__wrapper_8hpp_source.html#l00065">65</a> of file <a class="el" href="program__options__wrapper_8hpp_source.html">program_options_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    {</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        <span class="keywordflow">try</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        {</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            variable = (*variables_map)[name].as&lt;T&gt;();</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        }</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        <span class="keywordflow">catch</span>(boost::exception_detail::clone_impl&lt;boost::exception_detail::error_info_injector&lt;boost::bad_any_cast&gt; &gt;&amp; e)</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        {</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            std::cerr &lt;&lt; <span class="stringliteral">&quot;\n\tERROR Option &quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot; queried from variables_map incorrectly in &quot;</span>;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;            std::cerr &lt;&lt; location  &lt;&lt; std::endl;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            mpi.<a class="code" href="structutilities_1_1MpiWrapper.html#a7ffe7ed2049a6b7feb5778886a0d522e">m_exitFlag</a> = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        }</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    }</div>
<div class="ttc" id="structutilities_1_1MpiWrapper_html_a7ffe7ed2049a6b7feb5778886a0d522e"><div class="ttname"><a href="structutilities_1_1MpiWrapper.html#a7ffe7ed2049a6b7feb5778886a0d522e">utilities::MpiWrapper::m_exitFlag</a></div><div class="ttdeci">bool m_exitFlag</div><div class="ttdef"><b>Definition:</b> <a href="mpi__wrapper_8hpp_source.html#l00067">mpi_wrapper.hpp:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acb04e305126905376344007e049f9ae8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t utilities::Key </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>key2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to generate a 64-bit hash key from 2 input arguments. </p>
<dl class="section return"><dt>Returns</dt><dd>combined 64-bit key </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key1</td><td>Key 1 </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="multi__key__hash_8hpp_source.html#l00059">59</a> of file <a class="el" href="multi__key__hash_8hpp_source.html">multi_key_hash.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    {</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceutilities.html#aa88f2e607b1e3541233edf2bd7ee44ab">utilities::Pack2x32</a>(key1, key2);</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_html_aa88f2e607b1e3541233edf2bd7ee44ab"><div class="ttname"><a href="namespaceutilities.html#aa88f2e607b1e3541233edf2bd7ee44ab">utilities::Pack2x32</a></div><div class="ttdeci">uint64_t Pack2x32(const uint32_t key1, const uint32_t key2)</div><div class="ttdef"><b>Definition:</b> <a href="serialize_8hpp_source.html#l00096">serialize.hpp:96</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aeba3ae5b3df05fa8bb813e193e265105"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t utilities::Key </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>key3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to generate a 64-bit hash key from 3 input arguments. </p>
<dl class="section return"><dt>Returns</dt><dd>combined 64-bit key </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key1</td><td>Key 1 </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 </td></tr>
    <tr><td class="paramname">key3</td><td>Key 3 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="multi__key__hash_8hpp_source.html#l00071">71</a> of file <a class="el" href="multi__key__hash_8hpp_source.html">multi_key_hash.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    {</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceutilities.html#ab78b0dbfe83aa9c7055214013b2d2b40">utilities::Pack4x16</a>(key1, key2, key3, 0);</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_html_ab78b0dbfe83aa9c7055214013b2d2b40"><div class="ttname"><a href="namespaceutilities.html#ab78b0dbfe83aa9c7055214013b2d2b40">utilities::Pack4x16</a></div><div class="ttdeci">uint64_t Pack4x16(const uint16_t key1, const uint16_t key2, const uint16_t key3, const uint16_t key4)</div><div class="ttdef"><b>Definition:</b> <a href="serialize_8hpp_source.html#l00121">serialize.hpp:121</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6ba8b5f1a9b0ffc02a8038527577d8d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t utilities::Key </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>key3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>key4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to generate a 64-bit hash key from 4 input arguments. </p>
<dl class="section return"><dt>Returns</dt><dd>combined 64-bit key </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key1</td><td>Key 1 </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 </td></tr>
    <tr><td class="paramname">key3</td><td>Key 3 </td></tr>
    <tr><td class="paramname">key4</td><td>Key 4 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="multi__key__hash_8hpp_source.html#l00084">84</a> of file <a class="el" href="multi__key__hash_8hpp_source.html">multi_key_hash.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    {</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceutilities.html#ab78b0dbfe83aa9c7055214013b2d2b40">utilities::Pack4x16</a>(key1, key2, key3, key4);</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_html_ab78b0dbfe83aa9c7055214013b2d2b40"><div class="ttname"><a href="namespaceutilities.html#ab78b0dbfe83aa9c7055214013b2d2b40">utilities::Pack4x16</a></div><div class="ttdeci">uint64_t Pack4x16(const uint16_t key1, const uint16_t key2, const uint16_t key3, const uint16_t key4)</div><div class="ttdef"><b>Definition:</b> <a href="serialize_8hpp_source.html#l00121">serialize.hpp:121</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a028c87729a53688016b10a2202ceb82b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t utilities::Key </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to generate a 64-bit hash key from 6 input arguments. </p>
<dl class="section return"><dt>Returns</dt><dd>combined 64-bit key </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key1</td><td>Key 1 </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 </td></tr>
    <tr><td class="paramname">key3</td><td>Key 3 </td></tr>
    <tr><td class="paramname">key4</td><td>Key 4 </td></tr>
    <tr><td class="paramname">key5</td><td>Key 5 </td></tr>
    <tr><td class="paramname">key6</td><td>Key 6 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="multi__key__hash_8hpp_source.html#l00098">98</a> of file <a class="el" href="multi__key__hash_8hpp_source.html">multi_key_hash.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    {</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceutilities.html#abf0d157baa23b47b75d49bf4bb08ff3f">utilities::Pack8x8</a>(key1, key2, key3, key4, key5, key6, 0, 0);</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_html_abf0d157baa23b47b75d49bf4bb08ff3f"><div class="ttname"><a href="namespaceutilities.html#abf0d157baa23b47b75d49bf4bb08ff3f">utilities::Pack8x8</a></div><div class="ttdeci">uint64_t Pack8x8(const uint8_t key1, const uint8_t key2, const uint8_t key3, const uint8_t key4, const uint8_t key5, const uint8_t key6, const uint8_t key7, const uint8_t key8)</div><div class="ttdef"><b>Definition:</b> <a href="serialize_8hpp_source.html#l00155">serialize.hpp:155</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae1ba1caa17dfee74cd81fea7018e53f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t utilities::Key </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to generate a 64-bit hash key from 8 input arguments. </p>
<dl class="section return"><dt>Returns</dt><dd>combined 64-bit key </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key1</td><td>Key 1 </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 </td></tr>
    <tr><td class="paramname">key3</td><td>Key 3 </td></tr>
    <tr><td class="paramname">key4</td><td>Key 4 </td></tr>
    <tr><td class="paramname">key5</td><td>Key 5 </td></tr>
    <tr><td class="paramname">key6</td><td>Key 6 </td></tr>
    <tr><td class="paramname">key7</td><td>Key 7 </td></tr>
    <tr><td class="paramname">key8</td><td>Key 8 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="multi__key__hash_8hpp_source.html#l00114">114</a> of file <a class="el" href="multi__key__hash_8hpp_source.html">multi_key_hash.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    {</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceutilities.html#abf0d157baa23b47b75d49bf4bb08ff3f">utilities::Pack8x8</a>(key1, key2, key3, key4, key5, key6, key7, key8);</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_html_abf0d157baa23b47b75d49bf4bb08ff3f"><div class="ttname"><a href="namespaceutilities.html#abf0d157baa23b47b75d49bf4bb08ff3f">utilities::Pack8x8</a></div><div class="ttdeci">uint64_t Pack8x8(const uint8_t key1, const uint8_t key2, const uint8_t key3, const uint8_t key4, const uint8_t key5, const uint8_t key6, const uint8_t key7, const uint8_t key8)</div><div class="ttdef"><b>Definition:</b> <a href="serialize_8hpp_source.html#l00155">serialize.hpp:155</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a820763bcab8f0447427b392b07dbdadb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T utilities::Modulo </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A template function that returns the result a modulo b, for both positive and negative values of a. </p>
<p>If a is negative and b is positive then e.g. -5 % 4 gives -1 because it acts on the numerical part of the binary, not the sign:</p>
<p>-5 is 1|101 and 4 is 0|100 ^ sign part</p>
<p>then 1|101 % 0|100 becomes a % operation on the part not representing the sign, so we get -(5%4), which gives -1.</p>
<p>We really wanted it to give 3, which is obtained by calculating 4 - abs(-1) % 4 = 3</p>
<p>NOTE: negative values of b are not treated correctly here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First argument in modulo function </td></tr>
    <tr><td class="paramname">b</td><td>Second argument in modulo function </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="modulo_8hpp_source.html#l00053">53</a> of file <a class="el" href="modulo_8hpp_source.html">modulo.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="keywordflow">return</span> a &gt;= 0 ? a % b : ( b - (T)std::abs ( a%b ) ) % b;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6715279226011811c3b4f3b41c36024b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t utilities::MurmurHasher64 </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template wrapper function for general use of seeded hash functions </p>

<p>Definition at line <a class="el" href="murmur__hash__wrapper_8hpp_source.html#l00071">71</a> of file <a class="el" href="murmur__hash__wrapper_8hpp_source.html">murmur_hash_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    {</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="murmur__hash2_8hpp.html#acbb16e185463b7382b12fd0ee1ee0e58">MurmurHash64A</a>(&amp;t, <span class="keyword">sizeof</span>(t), seed);</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    }</div>
<div class="ttc" id="murmur__hash2_8hpp_html_acbb16e185463b7382b12fd0ee1ee0e58"><div class="ttname"><a href="murmur__hash2_8hpp.html#acbb16e185463b7382b12fd0ee1ee0e58">MurmurHash64A</a></div><div class="ttdeci">uint64_t MurmurHash64A(const void *key, int len, uint64_t seed)</div><div class="ttdef"><b>Definition:</b> <a href="murmur__hash2_8cpp_source.html#l00096">murmur_hash2.cpp:96</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a64be4b24f7781ae39f5dbfeb01a33659"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structutilities_1_1KahanAccumulation.html">KahanAccumulation</a>&lt;T&gt;&amp; utilities::operator+= </td>
          <td>(</td>
          <td class="paramtype">KahanAccumulation&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a global template += operator overload for the Kahan accumulator class. Call as simply a += b where a is an existing <a class="el" href="structutilities_1_1KahanAccumulation.html">KahanAccumulation</a> object and b is the numerical value to be added to the sum (should be of the same type as the class type) </p>
<dl class="section return"><dt>Returns</dt><dd>address to the updated <a class="el" href="structutilities_1_1KahanAccumulation.html">KahanAccumulation</a> object </dd></dl>

<p>Definition at line <a class="el" href="kahan__arithmetic_8hpp_source.html#l00066">66</a> of file <a class="el" href="kahan__arithmetic_8hpp_source.html">kahan_arithmetic.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    {</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        T tempVal = b - a.m_correction;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        T tempSum = a.m_sum + tempVal;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        a.m_correction = (tempSum - a.m_sum) - tempVal;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        a.m_sum = tempSum;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a82140e289799af3dd4f0638c730faf3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t utilities::Pack2x16 </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>key2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A conversion function for serializing two 16 bit values into one 32 bit value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key1</td><td>Key 1 set to second 16 bits </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 set to first 16 bits </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="serialize_8hpp_source.html#l00071">71</a> of file <a class="el" href="serialize_8hpp_source.html">serialize.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        <span class="keywordflow">return</span> ((uint32_t)key1 &lt;&lt; 0x10) | (uint32_t)key2;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa88f2e607b1e3541233edf2bd7ee44ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t utilities::Pack2x32 </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>key2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A conversion function for serializing two 32 bit values into one 64 bit value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key1</td><td>Key 1 set to second 32 bits </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 set to first 32 bits </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="serialize_8hpp_source.html#l00096">96</a> of file <a class="el" href="serialize_8hpp_source.html">serialize.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    {</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <span class="keywordflow">return</span> ((uint64_t)key1 &lt;&lt; 0x20) | (uint64_t)key2;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6c3189851e15d3e3b0138be97bcadc4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t utilities::Pack2x8 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A conversion function for serializing two 8 bit values into one 16 bit value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key1</td><td>Key 1 set to second 8 bits </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 set to first 8 bits </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="serialize_8hpp_source.html#l00046">46</a> of file <a class="el" href="serialize_8hpp_source.html">serialize.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    {</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        <span class="keywordflow">return</span> ((uint16_t)key1 &lt;&lt; 0x8) | (uint16_t)key2;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab78b0dbfe83aa9c7055214013b2d2b40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t utilities::Pack4x16 </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>key3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>key4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A conversion function for serializing four 16 bit values into one 64 bit value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key1</td><td>Key 1 set to fourth 16 bits </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 set to third 16 bits </td></tr>
    <tr><td class="paramname">key3</td><td>Key 3 set to second 16 bits </td></tr>
    <tr><td class="paramname">key4</td><td>Key 4 set to first 16 bits </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="serialize_8hpp_source.html#l00121">121</a> of file <a class="el" href="serialize_8hpp_source.html">serialize.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    {</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        <span class="keyword">const</span> uint64_t temp1 = ((uint64_t)key1 &lt;&lt; 0x10) | (uint64_t)key2;</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <span class="keyword">const</span> uint64_t temp2 = ((uint64_t)key3 &lt;&lt; 0x10) | (uint64_t)key4;</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceutilities.html#aa88f2e607b1e3541233edf2bd7ee44ab">Pack2x32</a>(temp1, temp2);</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_html_aa88f2e607b1e3541233edf2bd7ee44ab"><div class="ttname"><a href="namespaceutilities.html#aa88f2e607b1e3541233edf2bd7ee44ab">utilities::Pack2x32</a></div><div class="ttdeci">uint64_t Pack2x32(const uint32_t key1, const uint32_t key2)</div><div class="ttdef"><b>Definition:</b> <a href="serialize_8hpp_source.html#l00096">serialize.hpp:96</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abf0d157baa23b47b75d49bf4bb08ff3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t utilities::Pack8x8 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A conversion function for serializing eight 8 bit values into one 64 bit value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key1</td><td>Key 1 set to eighth 8 bits </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 set to seventh 8 bits </td></tr>
    <tr><td class="paramname">key3</td><td>Key 3 set to sixth 8 bits </td></tr>
    <tr><td class="paramname">key4</td><td>Key 4 set to fith 8 bits </td></tr>
    <tr><td class="paramname">key5</td><td>Key 5 set to fourth 8 bits </td></tr>
    <tr><td class="paramname">key6</td><td>Key 6 set to third 8 bits </td></tr>
    <tr><td class="paramname">key7</td><td>Key 7 set to second 8 bits </td></tr>
    <tr><td class="paramname">key8</td><td>Key 8 set to first 8 bits </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="serialize_8hpp_source.html#l00155">155</a> of file <a class="el" href="serialize_8hpp_source.html">serialize.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    {</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        <span class="keyword">const</span> uint64_t temp1 = ((uint64_t)key1 &lt;&lt; 0x8) | (uint64_t)key2;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        <span class="keyword">const</span> uint64_t temp2 = ((uint64_t)key3 &lt;&lt; 0x8) | (uint64_t)key4;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        <span class="keyword">const</span> uint64_t temp3 = ((uint64_t)key5 &lt;&lt; 0x8) | (uint64_t)key6;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        <span class="keyword">const</span> uint64_t temp4 = ((uint64_t)key7 &lt;&lt; 0x8) | (uint64_t)key8;</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceutilities.html#ab78b0dbfe83aa9c7055214013b2d2b40">Pack4x16</a>(temp1, temp2, temp3, temp4);</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_html_ab78b0dbfe83aa9c7055214013b2d2b40"><div class="ttname"><a href="namespaceutilities.html#ab78b0dbfe83aa9c7055214013b2d2b40">utilities::Pack4x16</a></div><div class="ttdeci">uint64_t Pack4x16(const uint16_t key1, const uint16_t key2, const uint16_t key3, const uint16_t key4)</div><div class="ttdef"><b>Definition:</b> <a href="serialize_8hpp_source.html#l00121">serialize.hpp:121</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8ca89a1ba48fbce62db30823827b3823"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , order_t O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::PartialQuickSort </td>
          <td>(</td>
          <td class="paramtype">K *&#160;</td>
          <td class="paramname"><em>keyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>valueList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nSort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts keys and values lists according to the keys list and returns after nSort values are in the correct order. This function is a wrapper to call the top level of the DoPairedSort recursion. </p>
<p>Template arguments: K: key data type, used for sorting V: value data type, not used for sorting O: Select from <em>ASCENDING_ORDER</em> or <em>DESCENDING_ORDER</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyList</td><td>Address of first list </td></tr>
    <tr><td class="paramname">valueList</td><td>Address of second list </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of list </td></tr>
    <tr><td class="paramname">nSort</td><td>Number of elements to sort before returning </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00272">272</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    {</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxSorted = 0;</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nSortActual = std::min(dim,nSort);</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        DoQuickSort&lt;K,V,O&gt;(keyList, valueList, dim, nSortActual, maxSorted);</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a62e2efbf7451dbf878abd66dead65af9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , order_t O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::PartialQuickSort </td>
          <td>(</td>
          <td class="paramtype">K *&#160;</td>
          <td class="paramname"><em>keyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nSort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the PartialQuickSort function in case where only a key list is available. In this case the key list is not required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyList</td><td>Address of first list </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of list </td></tr>
    <tr><td class="paramname">nSort</td><td>Number of elements to sort before returning </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00288">288</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    {</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxSorted = 0;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nSortActual = std::min(dim, nSort);</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        V* valueList = <span class="keyword">new</span> V[dim];</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        DoQuickSort&lt;K, V, O&gt;(keyList, valueList, dim, nSortActual, maxSorted);</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        <span class="keyword">delete</span>[] valueList;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8a324083a2609dbfaf7f4c7c061a642e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , order_t O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::PartialQuickSort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nSort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the PartialQuickSort function for std::vector data structures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyList</td><td>Address of list (as a std::vector) </td></tr>
    <tr><td class="paramname">nSort</td><td>Number of elements to sort before returning </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00304">304</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    {</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxSorted = 0;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = keyList.size();</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nSortActual = std::min(dim, nSort);</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        V* valueList = <span class="keyword">new</span> V[dim];</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        DoQuickSort&lt;K,V,O&gt;(keyList.data(), valueList, dim, nSortActual, maxSorted);</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        <span class="keyword">delete</span>[] valueList;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6c6360e7d29cb5c366b2813125684240"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , order_t O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::QuickSort </td>
          <td>(</td>
          <td class="paramtype">K *&#160;</td>
          <td class="paramname"><em>keyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>valueList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts keys and values lists according to the keys list. This function is a wrapper to call the top level of the DoPairedSort recursion. </p>
<p>Template arguments: K: key data type, used for sorting V: value data type, not used for sorting O: Select from <em>ASCENDING_ORDER</em> or <em>DESCENDING_ORDER</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyList</td><td>Address of first list </td></tr>
    <tr><td class="paramname">valueList</td><td>Address of second list </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of list </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00326">326</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    {</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxSorted = 0;</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        DoQuickSort&lt;K, V, O&gt;(keyList, valueList, dim, dim, maxSorted);</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a847133334345e4979fbe17eb7e9ab4c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , order_t O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::QuickSort </td>
          <td>(</td>
          <td class="paramtype">K *&#160;</td>
          <td class="paramname"><em>keyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the QuickSort function in case where only a key list is available. In this case the key list is not required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyList</td><td>Address of first list </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of list </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00340">340</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    {</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxSorted = 0;</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        V* valueList = <span class="keyword">new</span> V[dim];</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        {</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;            valueList[i] = 0;</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        }</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        DoQuickSort&lt;K,V,O&gt;(keyList, valueList, dim, dim, maxSorted);</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        <span class="keyword">delete</span>[] valueList;</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a24bf9f1e05191efbf167362c0df48102"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , order_t O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::QuickSort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the QuickSort function for std::vector data structures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyList</td><td>Address of list (as a std::vector) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00358">358</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    {</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxSorted = 0;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = keyList.size();</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        V* valueList = <span class="keyword">new</span> V[dim];</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;        {</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;            valueList[i] = i;</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        }</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        DoQuickSort&lt;K,V,O&gt;(keyList.data(), valueList, dim, dim, maxSorted);</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;        <span class="keyword">delete</span>[] valueList;</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae9d4d9a9873d5f7908484e6aa41c2fd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::SameTest </td>
          <td>(</td>
          <td class="paramtype">CrsSparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CrsSparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator to test if two <a class="el" href="classutilities_1_1CrsSparseMatrix.html" title="A template class to implement the compressed row storage sparse matrix format. ">CrsSparseMatrix</a> data structures are identical up to a given tolerence. Only classes with the same template arguments can be compared. </p>
<p>Note that the comparison algorithm requires an in-place sort of the underlying data and column arrays in the <a class="el" href="classutilities_1_1CrsSparseMatrix.html" title="A template class to implement the compressed row storage sparse matrix format. ">CrsSparseMatrix</a> class. This does not change the data represented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>lhs matrix to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>rhs matrix to compare </td></tr>
    <tr><td class="paramname">tol</td><td>comparison tolerence </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="crs__sparse__matrix_8hpp_source.html#l00067">67</a> of file <a class="el" href="crs__sparse__matrix_8hpp_source.html">crs_sparse_matrix.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    {</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        <span class="keywordflow">if</span>(</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        (lhs.GetNbrNonZeros() != rhs.GetNbrNonZeros()) ||</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        (lhs.m_rowStarts      != rhs.m_rowStarts)</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        )</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        {</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        }</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        <span class="comment">//  In CRS format the row data is always stored in order</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;lhs.GetNbrRows(); ++i)</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        {</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            <span class="comment">//  For each row, we need to ensure that the column indices are </span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;            <span class="comment">//  in the same order (since this is not necessarily guaranteed)</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            <span class="comment">//  So run a quick sort to rearrange the columns and their </span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            <span class="comment">//  corresponding data entries</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            <span class="keywordtype">int</span> startCol = lhs.m_rowStarts[i];</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;            <span class="keywordtype">int</span> endCol   = lhs.m_rowStarts[i+1];</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            utilities::QuickSort&lt;int, T, _ASCENDING_ORDER_&gt;(&amp;lhs.m_cols[startCol], </div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                                                            &amp;lhs.m_data[startCol], endCol-startCol);</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            utilities::QuickSort&lt;int, T ,_ASCENDING_ORDER_&gt;(&amp;rhs.m_cols[startCol], </div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                                                            &amp;rhs.m_data[startCol], endCol-startCol);</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        }</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        <span class="comment">//  Now test for equality of the underlying data structures</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        <span class="keywordflow">if</span>(lhs.m_cols != rhs.m_cols)</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        {</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        }</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;dcmplx, T&gt;::value</a>)</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        {</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;lhs.GetNbrNonZeros(); ++i)</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;            {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                <span class="keywordflow">if</span>(abs(lhs.m_data[i]-rhs.m_data[i])&gt;tol)    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            }</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        }</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;double,T&gt;::value</a>)</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        {</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;lhs.GetNbrNonZeros(); ++i)</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            {</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                <span class="keywordflow">if</span>(fabs(lhs.m_data[i]-rhs.m_data[i])&gt;tol)   <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            }</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        }</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    }</div>
<div class="ttc" id="structutilities_1_1is__same_html"><div class="ttname"><a href="structutilities_1_1is__same.html">utilities::is_same</a></div><div class="ttdoc">A template to check that two types are the same (as implemented by the function std::is_same in C++11...</div><div class="ttdef"><b>Definition:</b> <a href="template__tools_8hpp_source.html#l00038">template_tools.hpp:38</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af0e23dff4b05b4b7f63377f11013c020"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::SameTest </td>
          <td>(</td>
          <td class="paramtype">MappedSparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappedSparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator to test if two <a class="el" href="classutilities_1_1CrsSparseMatrix.html" title="A template class to implement the compressed row storage sparse matrix format. ">CrsSparseMatrix</a> data structures are identical up to a given tolerence. Only classes with the same template arguments can be compared. </p>
<p>Note that the comparison algorithm requires an in-place sort of the underlying data and column arrays in the <a class="el" href="classutilities_1_1CrsSparseMatrix.html" title="A template class to implement the compressed row storage sparse matrix format. ">CrsSparseMatrix</a> class. This does not change the data represented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>lhs matrix to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>rhs matrix to compare </td></tr>
    <tr><td class="paramname">tol</td><td>comparison tolerence </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mapped__sparse__matrix_8hpp_source.html#l00090">90</a> of file <a class="el" href="mapped__sparse__matrix_8hpp_source.html">mapped_sparse_matrix.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    {</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        <span class="keywordflow">if</span>(</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        (lhs.GetNbrNonZeros() != rhs.GetNbrNonZeros()) ||</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        (lhs.GetNbrRows()     != rhs.GetNbrRows())     ||</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        (lhs.GetNbrColumns()  != rhs.GetNbrColumns())</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        )</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        {</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        }</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;dcmplx, T&gt;::value</a>)</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        {</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> it = lhs.m_map.begin(); it != lhs.m_map.end(); ++it)</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            {</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                uint32_t row;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                uint32_t col;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                <a class="code" href="namespaceutilities.html#a307f22a0ca92ed7ec48931314b9cf8dd">utilities::Unpack2x32</a>(it-&gt;first, row, col);</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                <span class="keywordflow">if</span>(abs(rhs.Value(row,col)-lhs.Value(row,col))&gt;tol)  </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                {</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                }</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;            }</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        }</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;double,T&gt;::value</a>)</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        {</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> it = lhs.m_map.begin(); it != lhs.m_map.end(); ++it)</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;            {</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;                uint32_t row;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                uint32_t col;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                <a class="code" href="namespaceutilities.html#a307f22a0ca92ed7ec48931314b9cf8dd">utilities::Unpack2x32</a>(it-&gt;first, row, col);</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                <span class="keywordflow">if</span>(abs(rhs.Value(row,col)-lhs.Value(row,col))&gt;tol)  </div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                {</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;                }</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            }</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        }</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    }</div>
<div class="ttc" id="structutilities_1_1is__same_html"><div class="ttname"><a href="structutilities_1_1is__same.html">utilities::is_same</a></div><div class="ttdoc">A template to check that two types are the same (as implemented by the function std::is_same in C++11...</div><div class="ttdef"><b>Definition:</b> <a href="template__tools_8hpp_source.html#l00038">template_tools.hpp:38</a></div></div>
<div class="ttc" id="namespaceutilities_html_a307f22a0ca92ed7ec48931314b9cf8dd"><div class="ttname"><a href="namespaceutilities.html#a307f22a0ca92ed7ec48931314b9cf8dd">utilities::Unpack2x32</a></div><div class="ttdeci">void Unpack2x32(const uint64_t index, uint32_t &amp;key1, uint32_t &amp;key2)</div><div class="ttdef"><b>Definition:</b> <a href="serialize_8hpp_source.html#l00107">serialize.hpp:107</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2dd63552e5e0ddf1735b427459222a91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int utilities::SizeOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A template function to count the total number of bytes in a variadic template parameter pack (requires c++11) </p>

<p>Definition at line <a class="el" href="template__tools_8hpp_source.html#l00091">91</a> of file <a class="el" href="template__tools_8hpp_source.html">template_tools.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    {</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        <span class="keywordflow">return</span> SizeOfImpl&lt;Ts...&gt;::Value();</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa4186e485e8332d7bdeca00b7ce89cc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::Swap </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A template for a swap function, to swap the contents of two memory addresses. This version is used as an alternative to the std::swap function which does not quite have the correct behaviour for this application (since std:swap swaps the pointers, not the addresses pointed to, given the same set of arguments as with this Swap function). </p>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00169">169</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    {</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keyword">const</span> T temp = *a;</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        *a = *b;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        *b = temp;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5aa7f7439072020c4a0dbd6f0fbe85b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string utilities::ToStream </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template function to parse different data types. In particular complex types don't have native parsing so need to be treated as a special case </p>

<p>Definition at line <a class="el" href="io__wrapper_8hpp_source.html#l00076">76</a> of file <a class="el" href="io__wrapper_8hpp_source.html">io_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    {</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        std::stringstream ss;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        ss.str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;dcmplx, T&gt;::value</a>)</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        {</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            <span class="keywordtype">double</span> re, im;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;            re = std::real(variable);</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            im = std::imag(variable);</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            ss &lt;&lt; std::setprecision(15) &lt;&lt; re &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; std::setprecision(15) &lt;&lt; im;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        }</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        {</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;            ss &lt;&lt; std::setprecision(15) &lt;&lt; variable;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        }</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="keywordflow">return</span> ss.str();</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    }</div>
<div class="ttc" id="structutilities_1_1is__same_html"><div class="ttname"><a href="structutilities_1_1is__same.html">utilities::is_same</a></div><div class="ttdoc">A template to check that two types are the same (as implemented by the function std::is_same in C++11...</div><div class="ttdef"><b>Definition:</b> <a href="template__tools_8hpp_source.html#l00038">template_tools.hpp:38</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6bb9f8e8d730a8d61070808dde979398"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::Unpack2x16 </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>key2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A conversion function for unserializing one 32 bit value into two 16 bit values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index packed with Pack2x16 </td></tr>
    <tr><td class="paramname">key1</td><td>Key 1 set to second 16 bits </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 set to first 16 bits </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="serialize_8hpp_source.html#l00082">82</a> of file <a class="el" href="serialize_8hpp_source.html">serialize.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        key1 = (uint16_t)((index &amp; 0xFFFF0000) &gt;&gt; 0x10);</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        key2 = (uint16_t)(index &amp; 0x0000FFFF);</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a307f22a0ca92ed7ec48931314b9cf8dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::Unpack2x32 </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>key2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A conversion function for unserializing one 64 bit value into two 32 bit values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index packed with Pack2x32 </td></tr>
    <tr><td class="paramname">key1</td><td>Key 1 set to second 32 bits </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 set to first 32 bits </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="serialize_8hpp_source.html#l00107">107</a> of file <a class="el" href="serialize_8hpp_source.html">serialize.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    {</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        key1 = (uint32_t)((index &amp; 0xFFFFFFFF00000000) &gt;&gt; 0x20);</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        key2 = (uint32_t)(index &amp; 0x00000000FFFFFFFF);</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abc87434bf622613d7849d56d37f885f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::Unpack2x8 </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>key2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A conversion function for unserializing one 16 bit value into two 8 bit values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index packed with Pack2x8 </td></tr>
    <tr><td class="paramname">key1</td><td>Key 1 set to second 8 bits </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 set to first 8 bits </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="serialize_8hpp_source.html#l00057">57</a> of file <a class="el" href="serialize_8hpp_source.html">serialize.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    {</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        key1 = (uint8_t)((index &amp; 0xFF00) &gt;&gt; 0x8);</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        key2 = (uint8_t)(index &amp; 0x00FF);</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a095a3b7adb942010942db6922145aebf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::Unpack4x16 </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>key3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>key4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A conversion function for unserializing one 64 bit value into four 16 bit values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index packed with Pack4x16 </td></tr>
    <tr><td class="paramname">key1</td><td>Key 1 set to fourth 16 bits </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 set to third 16 bits </td></tr>
    <tr><td class="paramname">key3</td><td>Key 3 set to second 16 bits </td></tr>
    <tr><td class="paramname">key4</td><td>Key 4 set to first 16 bits </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="serialize_8hpp_source.html#l00136">136</a> of file <a class="el" href="serialize_8hpp_source.html">serialize.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    {</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        uint32_t temp1;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        uint32_t temp2;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        <a class="code" href="namespaceutilities.html#a307f22a0ca92ed7ec48931314b9cf8dd">Unpack2x32</a>(index, temp1, temp2);  </div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        <a class="code" href="namespaceutilities.html#a6bb9f8e8d730a8d61070808dde979398">Unpack2x16</a>(temp1, key1, key2);</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        <a class="code" href="namespaceutilities.html#a6bb9f8e8d730a8d61070808dde979398">Unpack2x16</a>(temp2, key3, key4);</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_html_a6bb9f8e8d730a8d61070808dde979398"><div class="ttname"><a href="namespaceutilities.html#a6bb9f8e8d730a8d61070808dde979398">utilities::Unpack2x16</a></div><div class="ttdeci">void Unpack2x16(const uint32_t index, uint16_t &amp;key1, uint16_t &amp;key2)</div><div class="ttdef"><b>Definition:</b> <a href="serialize_8hpp_source.html#l00082">serialize.hpp:82</a></div></div>
<div class="ttc" id="namespaceutilities_html_a307f22a0ca92ed7ec48931314b9cf8dd"><div class="ttname"><a href="namespaceutilities.html#a307f22a0ca92ed7ec48931314b9cf8dd">utilities::Unpack2x32</a></div><div class="ttdeci">void Unpack2x32(const uint64_t index, uint32_t &amp;key1, uint32_t &amp;key2)</div><div class="ttdef"><b>Definition:</b> <a href="serialize_8hpp_source.html#l00107">serialize.hpp:107</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a48f08a26fc2b365a16c0a0e9fe09e716"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::Unpack8x8 </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>key3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>key4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>key5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>key6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>key7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>key8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A conversion function for unserializing one 64 bit value into eight 8 bit values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index packed with Pack8x8 </td></tr>
    <tr><td class="paramname">key1</td><td>Key 1 set to eighth 8 bits </td></tr>
    <tr><td class="paramname">key2</td><td>Key 2 set to seventh 8 bits </td></tr>
    <tr><td class="paramname">key3</td><td>Key 3 set to sixth 8 bits </td></tr>
    <tr><td class="paramname">key4</td><td>Key 4 set to fith 8 bits </td></tr>
    <tr><td class="paramname">key5</td><td>Key 5 set to fourth 8 bits </td></tr>
    <tr><td class="paramname">key6</td><td>Key 6 set to third 8 bits </td></tr>
    <tr><td class="paramname">key7</td><td>Key 7 set to second 8 bits </td></tr>
    <tr><td class="paramname">key8</td><td>Key 8 set to first 8 bits </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="serialize_8hpp_source.html#l00176">176</a> of file <a class="el" href="serialize_8hpp_source.html">serialize.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    {</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        uint16_t temp1;</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        uint16_t temp2;</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        uint16_t temp3;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        uint16_t temp4;</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        <a class="code" href="namespaceutilities.html#a095a3b7adb942010942db6922145aebf">Unpack4x16</a>(index, temp1, temp2, temp3, temp4);</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        <a class="code" href="namespaceutilities.html#abc87434bf622613d7849d56d37f885f3">Unpack2x8</a>(temp1, key1, key2);</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        <a class="code" href="namespaceutilities.html#abc87434bf622613d7849d56d37f885f3">Unpack2x8</a>(temp2, key3, key4);</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        <a class="code" href="namespaceutilities.html#abc87434bf622613d7849d56d37f885f3">Unpack2x8</a>(temp3, key5, key6);</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        <a class="code" href="namespaceutilities.html#abc87434bf622613d7849d56d37f885f3">Unpack2x8</a>(temp4, key7, key8);</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_html_a095a3b7adb942010942db6922145aebf"><div class="ttname"><a href="namespaceutilities.html#a095a3b7adb942010942db6922145aebf">utilities::Unpack4x16</a></div><div class="ttdeci">void Unpack4x16(const uint64_t index, uint16_t &amp;key1, uint16_t &amp;key2, uint16_t &amp;key3, uint16_t &amp;key4)</div><div class="ttdef"><b>Definition:</b> <a href="serialize_8hpp_source.html#l00136">serialize.hpp:136</a></div></div>
<div class="ttc" id="namespaceutilities_html_abc87434bf622613d7849d56d37f885f3"><div class="ttname"><a href="namespaceutilities.html#abc87434bf622613d7849d56d37f885f3">utilities::Unpack2x8</a></div><div class="ttdeci">void Unpack2x8(const uint16_t index, uint8_t &amp;key1, uint8_t &amp;key2)</div><div class="ttdef"><b>Definition:</b> <a href="serialize_8hpp_source.html#l00057">serialize.hpp:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ae923787d35bb2fff3ded45e174f1756c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const long int utilities::binomialLookUpTable[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>BINOMIAL TABLE ////////////////////////////////////////////</p>
<p>Stores non-trivial binomial coefficients up to 64 choose 64</p>
<p>Array structure:</p>
<p>4c2, 5c2, 6c2,6c3, 7c2,7c3, 8c2,8c3,8c4, 9c2,9c3,9c4, 10c2,10c3,10c4,10c5, etc... </p>

<p>Definition at line <a class="el" href="binomials_8hpp_source.html#l00088">88</a> of file <a class="el" href="binomials_8hpp_source.html">binomials.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8bd217ae821e52872836b15f651f5d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutilities_1_1Cout.html">utilities::Cout</a> utilities::cout</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify an extern declaration meaning that every file including coutTools.hpp expects an <a class="el" href="classutilities_1_1Cout.html" title="Define a class to contain functions that control the verbosity level of cout output. An object of this class type should be declared as a global extern, with a single instance declared in the main file. ">Cout</a> struct to be declared once </p>

<p>Definition at line <a class="el" href="optical__flux__lattice__noninteracting__model_8cpp_source.html#l00035">35</a> of file <a class="el" href="optical__flux__lattice__noninteracting__model_8cpp_source.html">optical_flux_lattice_noninteracting_model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a58897161c5ac004869b8f994de5ff4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int utilities::maxBinomial = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum argument n or r for Tabulated coefficients n choose r </p>

<p>Definition at line <a class="el" href="binomials_8hpp_source.html#l00039">39</a> of file <a class="el" href="binomials_8hpp_source.html">binomials.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceutilities.html">utilities</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
